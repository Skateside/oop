<!doctype html>
<html lang="en-GB">
<head>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1, width=device-width">
<title>Design Patterns</title>

<link rel="stylesheet" href="../reveal/css/reveal.css">
<link rel="stylesheet" href="../reveal/css/theme/black.css">
<link rel="stylesheet" href="../reveal/lib/css/zenburn.css">
<link rel="stylesheet" href="../custom.css">
<link rel="stylesheet" href="../reveal/css/print/pdf.css" media="print">

</head>
<body>

<div class="reveal">
    <div class="slides">

<section>
    <h1>Design Patterns</h1>
    <p>Common OOP patterns.</p>
</section>

<!-- What is a design pattern? -->

<section>

    <section>
        <h2 style="color:fuchsia">(insert title here)</h2>
    </section>

    <section>

        <div class="o-pack">
            <div class="box">
                <h2 class="box__title">Creational</h2>
                <ul class="box__list">
                    <li>Abstract factory</li>
                    <li>Builder</li>
                    <li class="js--fragment--one js--fragment--two // display">Factory</li>
                    <li>Prototype</li>
                    <li class="js--fragment--one js--fragment--two // display">Singleton</li>
                </ul>
            </div>
            <div class="box">
                <h2 class="box__title">Structural</h2>
                <ul class="box__list">
                    <li class="js--fragment--one js--fragment--two // display">Adapter</li>
                    <li class="js--fragment--one // display">Bridge</li>
                    <li class="js--fragment--one js--fragment--two // display">Composite</li>
                    <li class="js--fragment--one js--fragment--two // display">Decorator</li>
                    <li class="js--fragment--one // display">Facade</li>
                    <li class="js--fragment--one // display">Flyweight</li>
                    <li class="js--fragment--one // display">Proxy</li>
                </ul>
            </div>
            <div class="box">
                <h2 class="box__title">Behavioural</h2>
                <ul class="box__list">
                    <li class="js--fragment--one // display">Chain of responsibility</li>
                    <li class="js--fragment--one // display">Command</li>
                    <li>Interpreter</li>
                    <li class="js--fragment--two // display">Iterator</li>
                    <li>Mediator</li>
                    <li>Memento</li>
                    <li class="js--fragment--one js--fragment--two // display">Observer</li>
                    <li>State</li>
                    <li>Strategy</li>
                    <li>Template method</li>
                    <li>Visitor</li>
                </ul>
            </div>
        </div>

        <div class="o-pack">

            <figure class="book">
                <img src="./design-patterns-book.jpg">
                <figcaption>Design Patterns (1994)</figcaption>
            </figure>

            <figure class="book // fragment" id="pro-js-dp">
                <img src="./pro-js-design-patterns-book.jpg">
                <figcaption>Pro JavaScript Design Patterns (2008)</figcaption>
            </figure>

        </div>

        <div class="fragment" id="this-talk"></div>

    </section>

</section>

<section>

    <section>
        <h2>Singleton Pattern</h2>
    </section>

    <section>

        <p>The singleton pattern limits itself so that only one instance can be created.</p>
        <p class="fragment">There are 3 ways to create a singleton.</p>

    </section>

    <section>

        <p>Option 1: checking during instantiation.</p>

        <pre><code class="js" data-trim>
class Singleton {
    constructor() {
        let instance = this.constructor.instance;
        if (instance) {
            return instance;
        }
        this.constructor.instance = this;
        // ...
    }
}
        </code></pre>
        <pre><code class="js" data-trim>
let s1 = new Singleton();
let s1_again = new Singleton();
        </code></pre>

        <div class="fragment">

            <p>Pros: created just like any other instance.</p>
            <p>Cons: can be confusing if parameters are involved.</p>

        </div>

    </section>

    <section>

        <p>Option 2: static function.</p>

        <pre><code class="js" data-trim>
class Singleton {
    static get() {
        if (!this.instance) {
            this.instance = new this();
        }
        return this.instance;
    }
    // ...
}
        </code></pre>
        <pre><code class="js" data-trim>
let s1 = Singleton.get();
let s1_again = Singleton.get();
        </code></pre>

        <div class="fragment">

            <p>Pros: more obvious that it's a singleton.</p>
            <p>Cons: doesn't prevent multiple instances being created.</p>

        </div>

    </section>

    <section>

        <p>Option 3: just use an object literal.</p>

        <pre><code class="js" data-trim>
let singleton = {
    // ...
};
        </code></pre>
        <pre><code class="js" data-trim>
let s1 = singleton;
let s1_again = singleton;
        </code></pre>

        <div class="fragment">

            <p>Pros: no function overhead, super efficient.</p>
            <p>Cons: doesn't use <code>class</code> keyword and therefore seems inferior.</p>

        </div>

        <aside class="notes">
            <p>Pro tip: programmers are super petty.</p>
        </aside>

    </section>

    <section>

        <h3>When to use the Singleton Pattern</h3>

        <p class="fragment">Er ...</p>
        <p class="fragment">Honestly, every time I've used this pattern, I've regretted it.</p>

        <aside class="notes">
            <p>I'm showing you so you recognise it.</p>
        </aside>

    </section>

</section>

<section>

    <section>
        <h2>Iterator Pattern</h2>
    </section>

    <section>

        <p>The iterator pattern exposes elements of an object sequentially without exposing the underlying data structure.</p>

        <aside class="notes">
            <p>It's, like, <em>way</em> cooler than it sounds.</p>
        </aside>

    </section>

    <section>

        <p>The key part of an Iterator is the <code>next</code> method which returns an object.</p>

        <pre><code class="js" data-trim>
class Iterator {
    constructor(iterable = []) {
        this.index = 0;
        this.length = iterable.length;
        this.iterable = iterable;
    }
    next() {
        let value = this.iterable[this.index];
        this.index += 1;
        return Object.freeze({
            value,
            done: this.index > this.length
        });
    }
}
        </code></pre>

        <aside class="notes">
            <p>A "Crockford Classless" version of this wouldn't expose the properties at all.</p>
        </aside>

    </section>

    <section>

        <p>The <code>next</code> method will return the value and whether or not the loop is complete.</p>
        <p>The final entry shouldn't have a value - any value will be ignored.</p>

        <pre><code class="js" data-trim>
let iterator = new Iterator(["one", "two", "three"]);
iterator.next(); // -&gt; { value: "one", done: false }
iterator.next(); // -&gt; { value: "two", done: false }
iterator.next(); // -&gt; { value: "three", done: false }
iterator.next(); // -&gt; { value: undefined, done: true }
        </code></pre>

        <aside class="notes">
            <p>I know what you're thinking: why not just loop over an array?</p>
        </aside>

    </section>

    <section>

        <p>Have you heard of a <code>for...of</code> loop?</p>

        <pre><code class="js" data-trim>
for (let item of ["one", "two", "three"]) {
    console.log(item);
}
// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <div class="fragment">

            <p>JavaScript allows you to define custom functionality for that using the <code>Symbol.iterator</code> method.</p>
            <p>That method needs to return an iterator.</p>

        </div>

        <pre class="fragment"><code class="js" data-trim>
class Iterator {
    // ...
    [Symbol.iterator]() {
        return this;
    }
}
        </code></pre>

    </section>

    <section>

        <pre><code class="js" data-trim>
let iterator = new Iterator(["one", "two", "three"]);

for (let item of iterator) {
    console.log(item);
}

// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <div class="fragment">

            <p>It also activates JavaScript's spread operator.</p>

            <pre><code class="js" data-trim>
[...iterator]; // -&gt; ["one", "two", "three"]
            </code></pre>

        </div>

    </section>

    <section>

        <p>An Iterator allows the items to be converted while being looped over without revealing that information.</p>

        <pre><code class="js" data-trim>
class Name {
    constructor(name) { this.name = name; }
    setAlias(alias) { this.alias = alias; }
    getName() { return this.alias || this.name; }
}

class Employees extends Iterator {
    next() {
        let value = this.iterable[this.index].getName();
        // ...
    }
}
        </code></pre>
    </section>
    <section>

        <p>As far as our loop knows, we just have an array of strings.</p>

        <pre><code class="js" data-trim>
let mark = new Name("Mark");
let james = new Name("James");
let jlo = new Name("James");
jlo.setAlias("JLo");

let employees = new Employees([mark, james, jlo])

for (let employee of employees) {
    console.log(employee);
}

// Logs: "Mark"
// Logs: "James"
// Logs: "JLo"
        </code></pre>

        <aside class="notes">
            <p>If we need to do something like HTML-entities -&gt; UTF-8 or enforce capitalisation, it won't polute the array.</p>
        </aside>

    </section>

    <section>

        <p>An Iterator can not only abstract the data that it's serving, it can abstract the underlying data structure as well.</p>
        <p>We've been using an array but it could also be an object <span class="fragment"><br>... or nothing at all.</span></p>

    </section>

    <section>

        <pre><code class="js" data-trim>
class Range extends Iterator {
    constructor(start, end) {
        super();
        this.start = start;
        this.length = end - start;
    }
    next() {
        this.iterable[this.index] = this.start;
        this.start += 1;
        return super.next();
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
for (let number of new Range(1, 5)) {
    console.log(number);
}

// Logs: 1
// Logs: 2
// Logs: 3
// Logs: 4
        </code></pre>

        <aside class="notes">
            <p>Here's an Iterator that doesn't populate its data until it needs to.</p>
        </aside>

    </section>

    <section>

        <p>If this interests you, JavaScript also has generators to simplify iterators.</p>

        <pre><code class="js" data-trim>
let iterable = {
    *[Symbol.iterator]() {
        yield "one";
        yield "two";
        yield "three";
    }
}

for (let value of iterable) {
    console.log(value);
}

// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <aside class="notes">
            <p>There are precious few times you can use this, but when you get the chance it's cool as hell.</p>
        </aside>

    </section>

</section>

<section>

    <section>
        <h2>Composite Pattern</h2>
    </section>

    <section>

        <p>The Composite pattern takes zero-or-more similar objects and treats them as one object.</p>

        <figure class="fragment">
            <img src="./branch-leaves.png" alt="" class="mini-image">
            <figcaption>It does this by having "branches" that contain objects and "leaves" which are the objects.</figcaption>
        </figure>

    </section>

    <section>

        <p>In abstract terms, it looks like this.</p>

        <pre><code class="js" data-trim>
class Branch {
    constructor() { this.nodes = []; }
    addNode(node) { this.nodes.push(node); }
    execute() { this.nodes.forEach((o) => o.execute()); }
}

class Leaf {
    execute() {/* ... */}
}
        </code></pre>

        <p>The important thing is that either a <code>Branch</code> or a <code>Leaf</code> can be passed to <code>addNode</code>.</p>

    </section>

    <section>

        <form class="o-pack" id="checkboxes-input">
            <input type="number" min="1" max="10" step="1" placeholder="1 - 10" required aria-label="Number of items" name="parents">
            <input type="number" min="1" max="10" step="1" placeholder="1 - 10" required aria-label="Maximum depth" name="depth">
            <input type="number" min="1" max="10" step="1" placeholder="1 - 10" required aria-label="Maximum number of children" name="children">
            <button type="submit">Generate</button>
        </form>

        <div class="checkboxes" id="checkboxes-output">
        </div>

        <aside class="notes">
            <p>This is <strong>{1}</strong> number of items, a maximum depth of <strong>{2}</strong> and each having a maximum of <strong>{3}</strong> children.</p>
            <p>This is the composite pattern except the branch and leaf are the same thing.</p>
        </aside>

    </section>

    <section>

        <p>The checkbox knows about its immediate children and it's closest parent.</p>

        <pre><code class="js" data-trim>
class Checkbox {
    constructor(input) {
        this.input = input;
        this.children = [];
        input.addEventListener("change", () => {
            this.setState(input.checked);
        });
    }
    setParent(parent) { this.parent = parent; }
    addChild(child) {
        child.setParent(this);
        this.children.push(child);
    }
    // ...
}
        </code></pre>

    </section>
    <section>

        <pre class="tall"><code class="js" data-trim>
class Checkbox {
    // ...
    setState(state) {
        if (this.isSetting) {
            return;
        }
        this.isSetting = true;
        if (typeof state === "boolean") {
            this.input.indeterminate = false;
            this.input.checked = state;
            this.children.forEach((kid) => kid.setState(state));
        } else if (state === "mixed") {
            this.input.checked = false;
            this.input.indeterminate = true;
        }
        if (this.parent) {
            this.parent.update();
        }
        this.isSetting = false;
    }
    // ...
}
        </code></pre>

        <aside class="notes">
            <p>This is the Composite Pattern magic.</p>
            <p>Because we can check a checkbox, it updates its children which then update the parent, we need the <code>isSetting</code> flag to prevent infinite loops.</p>
        </aside>

    </section>
    <section>

        <pre class="tall"><code class="js" data-trim>
class Checkbox {
    // ...
    update() {
        let mixed = 0; let checked = 0;
        this.children.forEach((child) => {
            let state = child.getState();
            if (state === "mixed") {
                mixed += 1;
            } else if (state) {
                checked += 1;
            }
        });
        if (checked === this.children.length) {
            this.setState(true);
        } else if (mixed || checked) {
            this.setState("mixed");
        } else {
            this.setState(false);
        }
    }
    // ...
}
        </code></pre>

        <aside class="notes">
            <p>This method checks how many childen are checked. If they all are, we should be checked.</p>
        </aside>

    </section>
    <section>

        <pre><code class="js" data-trim>
class Checkbox {
    // ...
    getState() {
        return (
            this.input.indeterminate
            ? "mixed"
            : this.input.checked
        );
    }
}
        </code></pre>

    </section>

    <section>

        <p>We do this dynamically, but it boils down to this:</p>

        <pre><code class="js" data-trim>
let c_1 = new Checkbox(document.getElementById("c_1"));
let c_1_1 = new Checkbox(document.getElementById("c_1_1"));
let c_1_2 = new Checkbox(document.getElementById("c_1_2"));

c_1.addChild(c_1_1);
c_1.addChild(c_1_2);
        </code></pre>

    </section>

    <section>

        <h3>Benefits of the Composite Pattern</h3>

        <ul>
            <li>You don't have to worry about the structure as a whole, just how a single node works.</li>
            <li>It can handle any level of nesting.</li>
        </ul>

        <p>Downsides include the potential to use a lot of memory.</p>
        <pre><code class="js" data-trim>
// How many checkbox will this check?
checkbox.setState(true);
        </code></pre>

        <aside class="notes">
            <p>Trick question: depends how many children there are and how many children they have.</p>
        </aside>

    </section>

</section>

<section>

    <section>
        <h2>Adapter Pattern</h2>
    </section>

    <section>

        <figure>
            <img src="./adapter.jpg" alt="">
            <figcaption>An adapter converts a strange input into a known output</figcaption>
        </figure>

    </section>

    <section>
        <p>If you need to work with a few different things that do a similar thing but in different ways, you probably need an adapter for them.</p>
    </section>

    <section>

        <p>As a practical example, I had to track all forms on the Epson website <em>and</em> track any errors, even though the forms are old and there have been a few validators used.</p>

        <pre class="fragment"><code class="js" data-trim>
class FormTracker {

    constructor(form) {

        this.form = form;
        this.discoverValidator();
        this.addHandlers();

    }

    // ...

}
        </code></pre>

    </section>
    <section>

        <p>It's a little more complicated than this, but basically:</p>

        <pre><code class="js" data-trim>
class FormTracker {
    // ...
    static adapters = [];
    discoverValidator() {
        let form = this.form;
        let Adapter = this.constructor.adapters.find(
            (adapter) => adapter.check(form)
        );
        if (Adapter) {
            this.validator = new Adapter(form);
        }
    }
    // ...
}
        </code></pre>

        <aside class="notes">
            <p>We actually check adapters in a Last-In-First-Out order.</p>
        </aside>

    </section>
    <section>

        <p>Again, there's a few more checks, but essentially:</p>

        <pre><code class="js" data-trim>
class FormTracker {
    // ...
    addHandlers() {
        let validator = this.validator;
        this.form.addEventListener("submit", () => {
            if (validator && validator.hasErrors()) {
                this.trackErrors(validator.getErrors());
            } else {
                this.trackSuccess();
            }
        });
    }
    trackErrors(errors) { /* ... */ }
    trackSuccess() { /* ... */ }
}
        </code></pre>

        <aside class="notes">
            <p>Due to jQuery Validation, we have to wait a bit after the form submission before checking.</p>
        </aside>

    </section>

    <section>

        <p>I created an abstract Adapter so all my adapters work the same way.</p>

        <pre><code class="js" data-trim>
class ValidationAdapter {
    static check(form) {
        return false;
    }
    constructor(form) {
        this.form = form;
    }
    getErrors() {
        return [];
    }
    hasErrors() {
        return this.getErrors().length > 0;
    }
}
        </code></pre>

        <aside class="notes">
            <p>I can also reject anything that doesn't inherit from my abstract class.</p>
        </aside>

    </section>
    <section>

        <p>Any form relying on HTML5 form validation gets tracked like this:</p>

        <pre><code class="js" data-trim>
class NativeValidationAdapter extends ValidationAdapter {
    static check(form) {
        return (
            !form.matches("[novalidate]")
            && ("reportValidity" in form)
        );
    }
    getErrors() {
        return [...this.form.querySelectorAll("...")]
            .filter((element) => !element.validity.valid)
            .map((element) => ({
                element, message: element.validationMessage
            }));
    }
}
        </code></pre>

    </section>
    <section>

        <p>jQuery Validation has all the info I need in its <code>errorList</code> property.</p>

        <pre><code class="js" data-trim>
class JqueryValidationAdapter extends ValidationAdapter {
    static check(form) {
        return Boolean($(form).data("validator"));
    }
    constructor(form) {
        super(form);
        this.validator = $(form).data("validator");
    }
    getErrors() {
        return this.validator.errorList;
    }
}
        </code></pre>

        <aside class="notes">
            <p>Notice how I can add properties and it doesn't cause any problems.</p>
        </aside>

    </section>
    <section>

        <p>The CO2 calculator had a custom validator that just changed the input border colour.</p>

        <pre><code class="js" data-trim>
class CO2CalculatorValidationAdapter extends ValidationAdapter {
    static check(form) { return form.id === "co2-calculator"; }
    getErrors() {
        return [...this.form.querySelectorAll("...")]
            .filter((element) => this.isErrorElement(element))
            .map((element) => ({
                element,
                message: "This field is required"
            }));
    }
    getBorderColor(element) {/* getComputedStyle... */}
    isErrorElement(element) {/* "red", "rgb(255, 0, 0)" ... */}
}
        </code></pre>

    </section>

    <section>

        <p>As you saw from the CO2 Calculator curve-ball, I don't need to change the <code>FormTracker</code> code if I see a validator I don't recognise.</p>
        <p>This completely future-proofs the tracking because any new validator can just have a new adapter.</p>

    </section>

</section>

<section>

    <section>
        <h2>Observer Pattern</h2>
    </section>

    <section>

        <p>The observer pattern updates other objects when something interesting has happened.</p>
        <p class="fragment">If you've ever used event listeners on DOM node, you've seen this pattern.</p>

    </section>

    <section>

        <p>A basic observer:</p>

        <pre><code class="js" data-trim>
class Observer {
    constructor() {
        this.events = {};
    }
    addEventListener(name, func) {
        if (!this.events[name]) {
            this.events[name] = [];
        }
        this.events[name].push(func);
    }
    dispatchEvent(name, data) {
        (this.events[name] || []).forEach((func) => func(data));
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let observer = new Observer();
observer.addEventListener("my-event", (data) => {/* ... */});
observer.dispatchEvent("my-event");
        </code></pre>

        <aside class="notes">
            <p>You'll see observers like this everywhere.</p>
        </aside>

    </section>

    <section>

        <p>The problem with that version is its fragility.</p>

        <pre><code class="js" data-trim>
observer.addEventListener("my-event", () => {
    console.log("1");
    DOES_NOT_EXIST++;
});
observer.addEventListener("my-event", () => {
    console.log("2");
});
observer.dispatchEvent("my-event");

// Logs: 1
// ReferenceError: DOES_NOT_EXIST is not defined
        </code></pre>

    </section>

    <section>

        <p>You can create a far more stable version using DOM nodes and <code>CustomEvent</code>.</p>

        <pre><code class="js" data-trim>
class Observer {
    constructor(eventElement = document.createElement("div")) {
        this.eventElement = eventElement;
    }
    addEventListener(name, handler) {
        this.eventElement.addEventListener(name, handler);
    }
    removeEventListener(name, handler) {
        this.eventElement.removeEventListener(name, handler);
    }
    // ...
}
        </code></pre>

        <aside class="notes">
            <p>By allowing us to change <code>eventElement</code>, we can delegate these events.</p>
        </aside>

    </section>

    <section>

        <pre class="tall"><code class="js" data-trim>
class Observer {
    // ...
    createEvent(name, detail) {
        return new CustomEvent(name, {
            bubbles: true,
            cancelable: true,
            detail
        });
    }
    dispatchEvent(event, detail) {
        if (typeof event === "string") {
            event = this.createEvent(event, detail);
        }
        this.eventElement.dispatchEvent(event);
        return event;
    }
}
        </code></pre>

    </section>

    <section>

        <p>Now the observer is very robust.</p>

        <pre><code class="js" data-trim>
observer.addEventListener("my-event", () => {
    console.log("1");
    DOES_NOT_EXIST++;
});
observer.addEventListener("my-event", () => {
    console.log("2");
});
observer.dispatchEvent("my-event");

// Logs: 1
// ReferenceError: DOES_NOT_EXIST is not defined
// Logs: 2
        </code></pre>

    </section>

    <section>

        <p>Sub-classing <code>Observer</code> allows you to set the <code>eventElement</code>.</p>

        <pre><code class="js" data-trim>
class Thing extends Observer {
    constructor(element) {
        super(element);
        // ...
    }
}
        </code></pre>
        <pre><code class="js" data-trim>
let thing = new Thing(document.querySelector("..."));
        </code></pre>

        <p>This allows you to delegate custom events if you wish.</p>

    </section>

    <section>

        <p>The observer pattern allows different objects to iteract without tightly coupling them.</p>

        <pre><code class="js" data-trim>
// Tight coupling.
class Widget {
    construct(gizmo) { this.gizmo = gizmo; }
    doSomething() { this.gizmo.doRelated(); }
}

let widget = new Widget(new Gizmo());
        </code></pre>
        <pre><code class="js" data-trim>
// Loose coupling.
class Widget extends Observer {
    doSomething() { this.dispatchEvent("something"); }
}

let widget = new Widget();
let gizmo = new Gizmo();
widget.addEventListener("something", () => gizmo.doRelated());
        </code></pre>

        <aside class="notes">
            <p>In the loose coupleing code, <code>Widget</code> and <code>Gizmo</code> don't know anything about each other.</p>
        </aside>

    </section>

    <section>

        <p>You can create an interface separately from your object.</p>

        <pre><code class="js" data-trim>
// Remember the Carousel example from last week?
carousel.addEventListener("hide-item", ({ detail }) => {
    detail.hidden = true;
});
carousel.addEventListener("show-item", ({ detail }) => {
    detail.hidden = false;
});
carousel.addEventListener("render", () => {
    prev.disabled = false;
    next.disabled = false;
});
carousel.addEventListener("start", () => prev.disabled = true);
carousel.addEventListener("end", () => next.disabled = true);
        </code></pre>

    </section>

</section>

<!--
    Decorator Pattern.
*   Composite Pattern.
*   Adapter Pattern.
*   Observer Pattern. (but in OOP ...)
    Factory Pattern. (it's mentioned a load of times ...)
*   Iterator Pattern. (https://en.wikipedia.org/wiki/Iterator_pattern)
*   Singleton Pattern.
-->



<section id="questions">
    <h1>Any questions?</h1>
</section>

    </div>
</div>



<!-- <script src="../reveal/lib/js/head.min.js"></script> -->
<script src="../reveal/js/reveal.js"></script>
<script>
Reveal.configure({
    pdfSeparateFragments: false,
    pdfMaxPagesPerSlide: 1
});
Reveal.initialize({
    dependencies: [
        // Speaker notes.
        {
            src: "../reveal/plugin/notes/notes.js",
            async: true
        },
        // Syntax highlighting.
        {
            src: "../reveal/plugin/highlight/highlight.js",
            async: true,
            callback: function () {
                hljs.initHighlightingOnLoad();
            }
        },
        // PDF printing.
        {
            src: "../reveal/plugin/print-pdf/print-pdf.js",
            async: true
        }
    ]
});
</script>
<script src="./colour-fragments.js"></script>
<script src="./Checkboxes.js"></script>

</body>
</html>
