<!doctype html>
<html lang="en-GB">
<head>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1, width=device-width">
<title>Design Patterns</title>

<link rel="stylesheet" href="../reveal/css/reveal.css">
<link rel="stylesheet" href="../reveal/css/theme/black.css">
<link rel="stylesheet" href="../reveal/lib/css/zenburn.css">
<link rel="stylesheet" href="../custom.css">
<link rel="stylesheet" href="../reveal/css/print/pdf.css" media="print">

</head>
<body>

<div class="reveal">
    <div class="slides">

<section>
    <h1>Design Patterns</h1>
    <p>Common OOP patterns.</p>
</section>

<section>

    <section>
        <h2>What is a design pattern?</h2>
    </section>

    <section>
        <p>Design patterns are general, reusable solutions to common programming problems.</p>
        <p class="fragment">They're templates that can sometimes be applied to the issue you're facing.</p>
    </section>

    <section>

        <div class="o-pack">
            <div class="box">
                <h2 class="box__title">Creational</h2>
                <ul class="box__list">
                    <li>Abstract factory</li>
                    <li>Builder</li>
                    <li class="js--fragment--one js--fragment--two // display">Factory</li>
                    <li>Prototype</li>
                    <li class="js--fragment--one js--fragment--two // display">Singleton</li>
                </ul>
            </div>
            <div class="box">
                <h2 class="box__title">Structural</h2>
                <ul class="box__list">
                    <li class="js--fragment--one js--fragment--two // display">Adapter</li>
                    <li class="js--fragment--one // display">Bridge</li>
                    <li class="js--fragment--one js--fragment--two // display">Composite</li>
                    <li class="js--fragment--one js--fragment--two // display">Decorator</li>
                    <li class="js--fragment--one // display">Facade</li>
                    <li class="js--fragment--one // display">Flyweight</li>
                    <li class="js--fragment--one // display">Proxy</li>
                </ul>
            </div>
            <div class="box">
                <h2 class="box__title">Behavioural</h2>
                <ul class="box__list">
                    <li class="js--fragment--one // display">Chain of responsibility</li>
                    <li class="js--fragment--one // display">Command</li>
                    <li>Interpreter</li>
                    <li class="js--fragment--two // display">Iterator</li>
                    <li class="js--fragment--two // display">Mediator</li>
                    <li>Memento</li>
                    <li class="js--fragment--one js--fragment--two // display">Observer</li>
                    <li>State</li>
                    <li>Strategy</li>
                    <li>Template method</li>
                    <li>Visitor</li>
                </ul>
            </div>
        </div>

        <div class="o-pack">

            <figure class="book">
                <img src="./design-patterns-book.jpg">
                <figcaption>Design Patterns (1994)</figcaption>
            </figure>

            <figure class="book // fragment" id="pro-js-dp">
                <img src="./pro-js-design-patterns-book.jpg">
                <figcaption>Pro JavaScript Design Patterns (2008)</figcaption>
            </figure>

        </div>

        <div class="fragment" id="this-talk"></div>

        <aside class="notes">
            <p>Design Patters (1994) by Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides ("Gang of Four") for C++.</p>
            <p>Pro JavaScript Design Patterns (2008) by Ross Harmes and Dustin Diaz.</p>
        </aside>

    </section>

</section>

<section><!-- Singleton -->

    <section>

        <h2>Singleton Pattern</h2>

        <aside class="notes">
            <p>Pattern 1/8</p>
        </aside>

    </section>

    <section>

        <p>The singleton pattern limits itself so that only one instance can be created.</p>
        <p class="fragment">There are 3 ways to create a singleton.</p>

    </section>

    <section>

        <p>Option 1: checking during instantiation.</p>

        <pre><code class="js" data-trim>
class Singleton {
    constructor() {
        let instance = this.constructor.instance;
        if (instance) {
            return instance;
        }
        this.constructor.instance = this;
        // ...
    }
}
        </code></pre>
        <pre><code class="js" data-trim>
let s1 = new Singleton();
let s1_again = new Singleton();
        </code></pre>

        <div class="fragment">

            <p>Pros: created just like any other instance.</p>
            <p>Cons: can be confusing if parameters are involved.</p>

        </div>

    </section>

    <section>

        <p>Option 2: static function.</p>

        <pre><code class="js" data-trim>
class Singleton {
    static get() {
        if (!this.instance) {
            this.instance = new this();
        }
        return this.instance;
    }
    // ...
}
        </code></pre>
        <pre><code class="js" data-trim>
let s1 = Singleton.get();
let s1_again = Singleton.get();
        </code></pre>

        <div class="fragment">

            <p>Pros: more obvious that it's a singleton.</p>
            <p>Cons: doesn't prevent multiple instances being created.</p>

        </div>

    </section>

    <section>

        <p>Option 3: just use an object literal.</p>

        <pre><code class="js" data-trim>
let singleton = {
    // ...
};
        </code></pre>
        <pre><code class="js" data-trim>
let s1 = singleton;
let s1_again = singleton;
        </code></pre>

        <div class="fragment">

            <p>Pros: no function overhead, super efficient.</p>
            <p>Cons: doesn't use <code>class</code> keyword and therefore seems inferior. It also looks more like data than structure.</p>

        </div>

        <aside class="notes">
            <p>Pro tip: programmers are super petty.</p>
            <p>I recommend <strong>Option 2</strong>.</p>
        </aside>

    </section>

    <section>

        <h3>When to use the Singleton Pattern</h3>

        <p class="fragment">Er ...</p>
        <p class="fragment">Honestly, almost every time I've used this pattern, I've regretted it.</p>

        <aside class="notes">
            <p>Last week's advice</p>
            <ul>
                <li>Keep your hands to yourself!</li>
                <li>Ask, don't take!</li>
                <li>Don't leave your toys lying around!</li>
                <li>Don't talk to strangers!</li>
            </ul>
        </aside>

    </section>

    <section>

        <p>Remember last week's advice of "don't leave your toys lying around"? A singleton is a good way around that.</p>

        <pre><code class="js" data-trim>
Singleton.get().setData("abc", 123);

// ...

let value = Singleton.get().getData("abc"); // -> 123
        </code></pre>

        <p class="fragment">This is why JavaScript namespaces tend to be objects. In OOP terms, they're singletons.</p>

    </section>

    <section>

        <p>Singletons can be useful when the same input would create the same result.</p>

        <pre><code class="js" data-trim>
class Hasher {
    static cache = {};
    static create(seed) {
        if (!this.cache[seed]) {
            this.cache[seed] = new this(seed);
        }
        return this.cache[seed];
    }
    constructor(seed) {
        // ...
    }
    // ...
}
        </code></pre>
        <pre><code class="js" data-trim>
let seedABC = Hasher.create("abc");
let seedDEF = Hasher.create("def");
// ...
let seed2 = Hasher.create("abc"); // same instance as seedABC.
        </code></pre>

        <aside class="notes">
            <p>Very useful if this does a lot of heavy-duty work (AJAX, DOM traversal etc.).</p>
            <p>This is more a case of <strong>memoisation</strong> than a singleton, but it's a similar idea.</p>
        </aside>

    </section>

    <section>

        <p>Before creating a singleton, make sure you have a good reason why you will only ever need one instance.</p>
        <p class="fragment">Pro tip: "there's only one on the page" is not a good reason.</p>

    </section>

</section><!-- Singleton -->

<section><!-- Mediator -->

    <section>

        <h2>Mediator Pattern</h2>

        <aside class="notes">
            <p>Pattern 2/8</p>
        </aside>

    </section>

    <section>
        <p>When you tightly couple objects, usually you just need the output of one object's method to be passed to another object's method. The mediator pattern does that.</p>
        <p class="fragment">Remember last week's advice "don't talk to strangers"? The mediator pattern breaks this advice so that other objects don't.</p>
    </section>

    <section>

        <p>In this example, <code>Thermometer</code> is tightly coupled to <code>Temperature</code>.</p>

        <pre><code class="js" data-trim>
class Temperature {
    constructor(value) {}
    celsius() {}
    fahrenheit() {}
}

class Thermometer {
    constructor(temperature) {
        this.temperature = temperature;
    }
    display() {
        alert(this.temperature.celsius() + "°C");
    }
}
        </code></pre>

    </section>

    <section>

        <p>With a small re-write of <code>Thermometer</code>, we can keep it loosely coupled from <code>Temperature</code>.</p>

        <pre><code class="js" data-trim>
class Thermometer {
    display(celsius) {
        alert(celsius + "°C");
    }
}

class ThermalMediator {
    constructor(temperature, thermometer) {
        this.temperature = temperature;
        this.thermometer = thermometer;
    }
    display() {
        this.thermometer.display(this.temperature.celsius());
    }
}
        </code></pre>

    </section>

    <section>

        <p>Now that they're loosely coupled, we can test <code>Thermometer</code> without having to create a <code>Temperature</code> object.</p>

        <pre class="tall"><code class="js" data-trim>
describe("Thermometer#display()", () => {

    let globalAlert = window.alert;
    let thermometer = new Thermometer();

    it("should alert when given a number", () => {
        let isAlerted = false;
        window.alert = () => isAlerted = true;
        thermometer.display(20);
        chai.assert.isTrue(isAlerted);
        window.alert = globalAlert;
    });

});
        </code></pre>

        <aside class="notes">
            <p>Maybe <code>Temperature</code> has to look up height above sea level or air pressure?</p>
            <p>What should happen if we pass ig a string or an object?</p>
            <p>Test suite is <strong>mocha</strong> and <strong>chai</strong>.</p>
        </aside>

    </section>

    <section>

        <p>Using a mediator, we don't need to know how the objects interact, we just need to know that the mediator will take care of it.</p>

        <pre><code class="js" data-trim>
// was:
thermometer.display(temperature.celsius());

// now:
mediator.display();
        </code></pre>

    </section>
    <section>

        <p>If we need to update how those objects work, we only need to update the mediator.</p>

        <pre><code class="js" data-trim>
class ThermalMediator {
    display() {
        this.thermometer.display(
            this.temperature.celsius(),
            this.temperature.getSymbol("celsius")
        );
    }
}

// still:
mediator.display();
        </code></pre>

    </section>

</section><!-- Mediator -->

<section><!-- Factory -->

    <section>

        <h2>Factory Pattern</h2>

        <aside class="notes">
            <p>Pattern 3/8</p>
        </aside>

    </section>

    <section>

        <p>Factories build things.</p>
        <p>If you need to create the same thing multiple times, a factory can help.</p>
        <p class="fragment">Because you usually care about what a factory builds more than the factory, they're usually singltons.</p>

    </section>

    <section>

        <p>Here's an example of a really simple factory.</p>

        <pre class="tall"><code class="js" data-trim>
class Factory {
    static get() {
        if (!this.instance) {
            this.instance = new this();
        }
        return this.instance;
    }
    constructor() {
        this.factories = {};
    }
    add(name, factory) {
        this.factories[name] = factory;
    }
    build(name, ...args) {
        return this.factory[name](...args);
    }
}
        </code></pre>

        <aside class="notes">
            <p>Do you recognise the singleton pattern?</p>
        </aside>

    </section>

    <section>

        <p>We add a few factories ready to be used.</p>

        <pre class="tall"><code class="js" data-trim>
let factory = Factory.get();

factory.add("popup", (id) => {
    let popup = new Popup(document.getElementById(id));
    document.addEventListener("click", (e) => {
        if (e.target.matches(`[data-target="#${id}"]`)) {
            e.preventDefault();
            popup.show();
        }
    });
    return popup;
});

factory.add("disclosure", (trigger) => {
    return new Disclosure(trigger);
});
        </code></pre>

    </section>

    <section>

        <p>We can build anytime we want.</p>

        <pre><code class="js" data-trim>
let factory = Factory.get();
let popup = factory.build("popup", "my-id");
        </code></pre>

        <div class="fragment">

            <p>We can also dynamically build as we need.</p>

            <pre><code class="js" data-trim>
document.querySelectorAll(".popup[id]").forEach((popup) => {
    popup.instance = factory.build("popup", popup.id);
});
document.querySelectorAll(".disclosure").forEach((trigger) => {
    trigger.instance = factory.build("disclosure", trigger);
});
            </code></pre>

        </div>

    </section>

    <section>

        <h3>When to use the Factory Pattern</h3>

        <ul>
            <li class="fragment">If creating an instance requires a lot of set-up.</li>
            <li class="fragment">If you need to dynamically create objects based on an environment you can't predict or user input.</li>
        </ul>

        <p class="fragment">Use the factory pattern sparingly. It adds complexity to your code and it's overkill for a simple class instantiation.</p>

        <aside class="notes">
            <p>If you class requires a lot of setup, it might be too complicated.</p>
        </aside>

    </section>

</section><!-- Factory -->

<section><!-- Adapter -->

    <section>

        <h2>Adapter Pattern</h2>

        <aside class="notes">
            <p>Pattern 4/8</p>
        </aside>

    </section>

    <section>

        <figure>
            <img src="./adapter.jpg" alt="">
            <figcaption>An adapter converts a strange input into a known output</figcaption>
        </figure>

    </section>

    <section>
        <p>If you need to work with a few different things that do a similar thing but in different ways, you probably need an adapter for them.</p>
    </section>

    <section>

        <p>As a practical example, I had to track all forms on the Epson website <em>and</em> track any errors, even though the forms are old and there have been a few validators used.</p>

        <pre class="fragment"><code class="js" data-trim>
class FormTracker {

    constructor(form) {

        this.form = form;
        this.discoverValidator();
        this.addHandlers();

    }

    // ...

}
        </code></pre>

    </section>
    <section>

        <p>It's a little more complicated than this, but basically:</p>

        <pre><code class="js" data-trim>
class FormTracker {
    // ...
    static adapters = [];
    discoverValidator() {
        let form = this.form;
        let Adapter = this.constructor.adapters.find(
            (adapter) => adapter.check(form)
        );
        if (Adapter) {
            this.validator = new Adapter(form);
        }
    }
    // ...
}
        </code></pre>

        <aside class="notes">
            <p>We actually check adapters in a Last-In-First-Out order.</p>
            <p>Do you recognise the factory pattern?</p>
        </aside>

    </section>
    <section>

        <p>Again, there's a few more checks, but essentially:</p>

        <pre><code class="js" data-trim>
class FormTracker {
    // ...
    addHandlers() {
        let validator = this.validator;
        this.form.addEventListener("submit", () => {
            if (validator && validator.hasErrors()) {
                this.trackErrors(validator.getErrors());
            } else {
                this.trackSuccess();
            }
        });
    }
    trackErrors(errors) { /* ... */ }
    trackSuccess() { /* ... */ }
}
        </code></pre>

        <aside class="notes">
            <p>Due to jQuery Validation, we have to wait a bit after the form submission before checking.</p>
        </aside>

    </section>

    <section>

        <p>I created an abstract Adapter so all my adapters work the same way.</p>

        <pre><code class="js" data-trim>
class ValidationAdapter {
    static check(form) {
        return false;
    }
    constructor(form) {
        this.form = form;
    }
    getErrors() {
        return [];
    }
    hasErrors() {
        return this.getErrors().length > 0;
    }
}
        </code></pre>

        <aside class="notes">
            <p>I can also reject anything that doesn't inherit from my abstract class.</p>
        </aside>

    </section>
    <section>

        <p>Any form relying on HTML5 form validation gets tracked like this:</p>

        <pre class="tall"><code class="js" data-trim>
class NativeValidationAdapter extends ValidationAdapter {
    static check(form) {
        return (
            !form.matches("[novalidate]")
            && ("reportValidity" in form)
        );
    }
    getErrors() {
        return [...this.form.querySelectorAll("...")]
            .filter((element) => !element.validity.valid)
            .map((element) => ({
                element,
                message: element.validationMessage
            }));
    }
}
        </code></pre>

    </section>
    <section>

        <p>jQuery Validation has all the info I need in its <code>errorList</code> property.</p>

        <pre><code class="js" data-trim>
class JqueryValidationAdapter extends ValidationAdapter {
    static check(form) {
        return Boolean($(form).data("validator"));
    }
    constructor(form) {
        super(form);
        this.validator = $(form).data("validator");
    }
    getErrors() {
        return this.validator.errorList;
    }
}
        </code></pre>

        <aside class="notes">
            <p>Notice how I can add properties and it doesn't cause any problems.</p>
        </aside>

    </section>
    <section>

        <p>The CO2 calculator had a custom validator that just changed the input border colour.</p>

        <pre class="tall"><code class="js" data-trim>
class CO2CalculatorValidationAdapter extends ValidationAdapter {
    static check(form) {
        return form.id === "co2-calculator";
    }
    getErrors() {
        return [...this.form.querySelectorAll("...")]
            .filter((element) => this.isErrorElement(element))
            .map((element) => ({
                element,
                message: "This field is required"
            }));
    }
    getBorderColor(element) {/* getComputedStyle... */}
    isErrorElement(element) {/* "red", "rgb(255, 0, 0)" ... */}
}
        </code></pre>

    </section>

    <section>

        <p>As you saw from the CO2 Calculator curve-ball, I don't need to change the <code>FormTracker</code> code if I see a validator I don't recognise.</p>
        <p>This completely future-proofs the tracking because any new validator can just have a new adapter.</p>

    </section>

</section><!-- Adapter -->

<section><!-- Observer -->

    <section>

        <h2>Observer Pattern</h2>

        <aside class="notes">
            <p>Pattern 5/8</p>
        </aside>

    </section>

    <section>

        <p>The observer pattern updates other objects when something interesting has happened.</p>
        <p class="fragment">If you've ever used event listeners on DOM nodes, you've seen this pattern.</p>

    </section>

    <section>

        <p>A basic observer:</p>

        <pre><code class="js" data-trim>
class Observer {
    constructor() {
        this.events = {};
    }
    addEventListener(name, func) {
        if (!this.events[name]) {
            this.events[name] = [];
        }
        this.events[name].push(func);
    }
    dispatchEvent(name, data) {
        (this.events[name] || []).forEach((func) => func(data));
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let observer = new Observer();
observer.addEventListener("my-event", (data) => {/* ... */});
observer.dispatchEvent("my-event");
        </code></pre>

        <aside class="notes">
            <p>You'll see observers like this everywhere.</p>
        </aside>

    </section>

    <section>

        <p>The problem with that version is its fragility.</p>

        <pre><code class="js" data-trim>
observer.addEventListener("my-event", () => {
    console.log("1");
    DOES_NOT_EXIST++;
});
observer.addEventListener("my-event", () => {
    console.log("2");
});
observer.dispatchEvent("my-event");

// Logs: 1
// ReferenceError: DOES_NOT_EXIST is not defined
        </code></pre>

    </section>

    <section>

        <p>You can create a far more stable version using DOM nodes and <code>CustomEvent</code>.</p>

        <pre><code class="js" data-trim>
class Observer {
    constructor(eventElement = document.createElement("div")) {
        this.eventElement = eventElement;
    }
    addEventListener(name, handler) {
        this.eventElement.addEventListener(name, handler);
    }
    removeEventListener(name, handler) {
        this.eventElement.removeEventListener(name, handler);
    }
    // ...
}
        </code></pre>

        <aside class="notes">
            <p>By allowing us to change <code>eventElement</code>, we can delegate these events.</p>
        </aside>

    </section>

    <section>

        <pre class="tall"><code class="js" data-trim>
class Observer {
    // ...
    createEvent(name, detail) {
        return new CustomEvent(name, {
            bubbles: true,
            cancelable: true,
            detail
        });
    }
    dispatchEvent(event, detail) {
        if (typeof event === "string") {
            event = this.createEvent(event, detail);
        }
        this.eventElement.dispatchEvent(event);
        return event;
    }
}
        </code></pre>

    </section>

    <section>

        <p>Now the observer is very robust.</p>

        <pre><code class="js" data-trim>
observer.addEventListener("my-event", () => {
    console.log("1");
    DOES_NOT_EXIST++;
});
observer.addEventListener("my-event", () => {
    console.log("2");
});
observer.dispatchEvent("my-event");

// Logs: 1
// ReferenceError: DOES_NOT_EXIST is not defined
// Logs: 2
        </code></pre>

    </section>

    <section>

        <p>Sub-classing <code>Observer</code> allows you to set the <code>eventElement</code>.</p>

        <pre><code class="js" data-trim>
class Thing extends Observer {
    constructor(element) {
        super(element);
        // ...
    }
}
        </code></pre>
        <pre><code class="js" data-trim>
let thing = new Thing(document.querySelector("..."));
        </code></pre>

        <p>This allows you to delegate custom events if you wish.</p>

    </section>

    <section>

        <p>The observer pattern allows different objects to iteract without tightly coupling them.</p>

        <pre><code class="js" data-trim>
// Tight coupling.
class Widget {
    construct(gizmo) { this.gizmo = gizmo; }
    doSomething() { this.gizmo.doRelated(); }
}

let widget = new Widget(new Gizmo());
        </code></pre>
        <pre><code class="js" data-trim>
// Loose coupling.
class Widget extends Observer {
    doSomething() { this.dispatchEvent("something"); }
}

let widget = new Widget();
let gizmo = new Gizmo();
widget.addEventListener("something", () => gizmo.doRelated());
        </code></pre>

        <aside class="notes">
            <p>In the loose coupleing code, <code>Widget</code> and <code>Gizmo</code> don't know anything about each other.</p>
        </aside>

    </section>

    <section>

        <p>You can create an interface separately from your object.</p>

        <pre><code class="js" data-trim>
// Remember the Carousel example from last week?
carousel.addEventListener("hide-item", ({ detail }) => {
    detail.hidden = true;
});
carousel.addEventListener("show-item", ({ detail }) => {
    detail.hidden = false;
});
carousel.addEventListener("render", () => {
    prev.disabled = false;
    next.disabled = false;
});
carousel.addEventListener("start", () => prev.disabled = true);
carousel.addEventListener("end", () => next.disabled = true);
        </code></pre>

    </section>

    <section>

        <p>Everytime you look at your code and think:</p>
        <p><q>I need to know when ...</q></p>
        <p>... you need an observer.</p>

        <div class="fragment">
            <p>If you've got an observer, don't be afraid to dispatch events you don't care about now.</p>
            <p>When something important happens, dispatch an event. You may need to know when that was in the future.</p>
        </div>

        <aside class="notes">
            <p>"Something important" is very subjective. Don't to it when <em>anything</em> happens, use your common sense.</p>
        </aside>

    </section>

</section><!-- Observer -->

<section><!-- Decorator -->

    <section>

        <h2>Decorator Pattern</h2>

        <aside class="notes">
            <p>Pattern 6/8</p>
        </aside>

    </section>

    <section>
        <p>The decorator pattern adds or modifies functionality at run-time.</p>
    </section>

    <section>

        <pre class="tall"><code class="js" data-trim>
class Sale {
    static decorators = {};
    constructor(price) {
        this.price = price;
    }
    getPrice() {
        return this.price;
    }
    decorate(decorator) {
        let decoration = this.constructor.decorators[decorator];
        if (!decoration) {
            throw new ReferenceError("...");
        }
        return Object.assign(
            Object.create(this),
            { uber: this },
            decoration
        );
    }
}
        </code></pre>

    </section>

    <section>

        <pre><code class="js" data-trim>
Sale.decorators.halfPrice = {
    getPrice() {
        return this.uber.getPrice() / 2;
    }
};
Sale.decorators.tax = {
    getPrice() {
        return this.uber.getPrice() * 1.2;
    }
};
        </code></pre>

        <pre class="fragment"><code class="js" data-trim>
let sale = new Sale(100);
sale.getPrice(); // -> 100

sale = sale.decorate("halfPrice");
sale.getPrice(); // -> 50

sale = sale.decorate("tax");
sale.getPrice(); // -> 60
        </code></pre>

    </section>

    <section>

        <pre class="tall"><code class="js" data-trim>
class Sale {
    // ...
    decorate(decorator) {
        let decoration = this.constructor.decorators[decorator];
        if (!decoration) {
            throw new ReferenceError("...");
        }
        Object.entries(decoration).forEach(([name, func]) => {
            let previous = this[name].bind(this);
            this[name] = (...args) => func(previous, ...args);
        });
    }
}
        </code></pre>

    </section>

    <section>

        <pre><code class="js" data-trim>
Sale.decorators.halfPrice = {
    getPrice(previous) {
        return previous() / 2;
    }
};
Sale.decorators.tax = {
    getPrice(previous) {
        return previous() * 1.2;
    }
};
        </code></pre>

        <pre class="fragment"><code class="js" data-trim>
let sale = new Sale(100);
sale.getPrice(); // -> 100

sale.decorate("halfPrice");
sale.getPrice(); // -> 50

sale.decorate("tax");
sale.getPrice(); // -> 60
        </code></pre>

    </section>

    <section>

        <p>The decorator pattern is really useful for user-selected options.</p>
        <p>Instead of a load of <code>if</code> statements, just add the decoration that the user wants.</p>

        <aside class="notes">
            <p>I think that using this pattern on <strong>First Tickets</strong> might be helpful.</p>
        </aside>

    </section>

</section><!-- Decorator -->

<section><!-- Composite -->

    <section>

        <h2>Composite Pattern</h2>

        <aside class="notes">
            <p>Pattern 7/8</p>
        </aside>

    </section>

    <section>

        <p>The Composite pattern takes zero-or-more similar objects and treats them as one object.</p>

        <figure class="fragment">
            <img src="./branch-leaves.png" alt="" class="mini-image">
            <figcaption>It does this by having "branches" that contain objects and "leaves" which are the objects.</figcaption>
        </figure>

    </section>

    <section>

        <p>In abstract terms, it looks like this.</p>

        <pre><code class="js" data-trim>
class Branch {
    constructor() { this.nodes = []; }
    addNode(node) { this.nodes.push(node); }
    execute() { this.nodes.forEach((o) => o.execute()); }
}

class Leaf {
    execute() {/* ... */}
}
        </code></pre>

        <p>The important thing is that either a <code>Branch</code> or a <code>Leaf</code> can be passed to <code>addNode</code>.</p>

        <aside class="notes">
            <p>This is an example of <strong>Polymorphism</strong>.</p>

    </section>

    <section>

        <form class="o-pack" id="checkboxes-input">
            <input type="number" min="1" max="10" step="1" placeholder="1 - 10" required aria-label="Number of items" name="parents">
            <input type="number" min="1" max="10" step="1" placeholder="1 - 10" required aria-label="Maximum depth" name="depth">
            <input type="number" min="1" max="10" step="1" placeholder="1 - 10" required aria-label="Maximum number of children" name="children">
            <button type="submit">Generate</button>
        </form>

        <div class="checkboxes" id="checkboxes-output">
        </div>

        <aside class="notes">
            <p>This is <strong>{1}</strong> number of items, a maximum depth of <strong>{2}</strong> and each having a maximum of <strong>{3}</strong> children.</p>
            <p>This is the composite pattern except the branch and leaf are the same thing.</p>
        </aside>

    </section>

    <section>

        <p>The checkbox knows about its immediate children and it's closest parent.</p>

        <pre class="tall"><code class="js" data-trim>
class Checkbox {
    constructor(input) {
        this.input = input;
        this.children = [];
        input.addEventListener("change", () => {
            this.setState(input.checked);
        });
    }
    setParent(parent) {
        this.parent = parent;
    }
    addChild(child) {
        child.setParent(this);
        this.children.push(child);
    }
    // ...
}
        </code></pre>

    </section>
    <section>

        <pre class="tall"><code class="js" data-trim>
class Checkbox {
    // ...
    setState(state) {
        if (this.isSetting) {
            return;
        }
        this.isSetting = true;
        if (typeof state === "boolean") {
            this.input.indeterminate = false;
            this.input.checked = state;
            this.children.forEach((kid) => kid.setState(state));
        } else if (state === "mixed") {
            this.input.checked = false;
            this.input.indeterminate = true;
        }
        if (this.parent) {
            this.parent.update();
        }
        this.isSetting = false;
    }
    // ...
}
        </code></pre>

        <aside class="notes">
            <p>This is the Composite Pattern magic.</p>
            <p>Because we can check a checkbox, it updates its children which then update the parent, we need the <code>isSetting</code> flag to prevent infinite loops.</p>
        </aside>

    </section>
    <section>

        <pre class="tall"><code class="js" data-trim>
class Checkbox {
    // ...
    update() {
        let mixed = 0; let checked = 0;
        this.children.forEach((child) => {
            let state = child.getState();
            if (state === "mixed") {
                mixed += 1;
            } else if (state) {
                checked += 1;
            }
        });
        if (checked === this.children.length) {
            this.setState(true);
        } else if (mixed || checked) {
            this.setState("mixed");
        } else {
            this.setState(false);
        }
    }
    // ...
}
        </code></pre>

        <aside class="notes">
            <p>This method checks how many childen are checked. If they all are, we should be checked.</p>
        </aside>

    </section>
    <section>

        <pre><code class="js" data-trim>
class Checkbox {
    // ...
    getState() {
        return (
            this.input.indeterminate
            ? "mixed"
            : this.input.checked
        );
    }
}
        </code></pre>

    </section>

    <section>

        <p>We do this dynamically, but it boils down to this:</p>

        <pre><code class="js" data-trim>
let c_1 = new Checkbox(document.getElementById("c_1"));
let c_1_1 = new Checkbox(document.getElementById("c_1_1"));
let c_1_2 = new Checkbox(document.getElementById("c_1_2"));

c_1.addChild(c_1_1);
c_1.addChild(c_1_2);
        </code></pre>

    </section>

    <section>

        <h3>Benefits of the Composite Pattern</h3>

        <ul>
            <li>You don't have to worry about the structure as a whole, just how a single node works.</li>
            <li>It can handle any level of nesting.</li>
        </ul>

        <p>Downsides include the potential to use a lot of memory.</p>
        <pre><code class="js" data-trim>
// How many checkbox will this check?
checkbox.setState(true);
        </code></pre>

        <aside class="notes">
            <p>Trick question: depends how many children there are and how many children they have.</p>
        </aside>

    </section>

</section><!-- Composite -->

<section><!-- Iterator -->

    <section>

        <h2>Iterator Pattern</h2>

        <aside class="notes">
            <p>Pattern 8/8</p>
        </aside>

    </section>

    <section>

        <p>The iterator pattern exposes elements of an object sequentially without exposing the underlying data structure.</p>

        <aside class="notes">
            <p>It's, like, <em>way</em> cooler than it sounds.</p>
        </aside>

    </section>

    <section>

        <p>The key part of an Iterator is the <code>next</code> method which returns an object.</p>

        <pre><code class="js" data-trim>
class Iterator {
    constructor(iterable = []) {
        this.index = 0;
        this.length = iterable.length;
        this.iterable = iterable;
    }
    next() {
        let value = this.iterable[this.index];
        this.index += 1;
        return Object.freeze({
            value,
            done: this.index > this.length
        });
    }
}
        </code></pre>

        <aside class="notes">
            <p>A "Crockford Classless" version of this wouldn't expose the properties at all.</p>
        </aside>

    </section>

    <section>

        <p>The <code>next</code> method will return the value and whether or not the loop is complete.</p>
        <p>The final entry shouldn't have a value - any value will be ignored.</p>

        <pre><code class="js" data-trim>
let iterator = new Iterator(["one", "two", "three"]);
iterator.next(); // -&gt; { value: "one", done: false }
iterator.next(); // -&gt; { value: "two", done: false }
iterator.next(); // -&gt; { value: "three", done: false }
iterator.next(); // -&gt; { value: undefined, done: true }
        </code></pre>

        <aside class="notes">
            <p>I know what you're thinking: why not just loop over an array?</p>
        </aside>

    </section>

    <section>

        <p>Have you heard of a <code>for...of</code> loop?</p>

        <pre><code class="js" data-trim>
for (let item of ["one", "two", "three"]) {
    console.log(item);
}
// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <div class="fragment">

            <p>JavaScript allows you to define custom functionality for that using the <code>Symbol.iterator</code> method.</p>
            <p>That method needs to return an iterator.</p>

        </div>

        <pre class="fragment"><code class="js" data-trim>
class Iterator {
    // ...
    [Symbol.iterator]() {
        return this;
    }
}
        </code></pre>

    </section>

    <section>

        <pre><code class="js" data-trim>
let iterator = new Iterator(["one", "two", "three"]);

for (let item of iterator) {
    console.log(item);
}

// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <div class="fragment">

            <p>It also activates JavaScript's spread operator.</p>

            <pre><code class="js" data-trim>
[...iterator]; // -&gt; ["one", "two", "three"]
            </code></pre>

        </div>

    </section>

    <section>

        <p>An Iterator allows the items to be converted while being looped over without revealing that information.</p>

        <pre><code class="js" data-trim>
class Name {
    constructor(name) { this.name = name; }
    setAlias(alias) { this.alias = alias; }
    getName() { return this.alias || this.name; }
}

class Employees extends Iterator {
    next() {
        let value = this.iterable[this.index].getName();
        // ...
    }
}
        </code></pre>
    </section>
    <section>

        <p>As far as our loop knows, we just have an array of strings.</p>

        <pre><code class="js" data-trim>
let mark = new Name("Mark");
let james = new Name("James");
let jlo = new Name("James");
jlo.setAlias("JLo");

let employees = new Employees([mark, james, jlo])

for (let employee of employees) {
    console.log(employee);
}

// Logs: "Mark"
// Logs: "James"
// Logs: "JLo"
        </code></pre>

        <aside class="notes">
            <p>If we need to do something like HTML-entities -&gt; UTF-8 or enforce capitalisation, it won't polute the array.</p>
            <p>This is an example of <strong>abstraction</strong>.</p>
        </aside>

    </section>

    <section>

        <p>An Iterator can not only abstract the data that it's serving, it can abstract the underlying data structure as well.</p>
        <p>We've been using an array but it could also be an object <span class="fragment"><br>... or nothing at all.</span></p>

    </section>

    <section>

        <pre><code class="js" data-trim>
class Range extends Iterator {
    constructor(start, end) {
        super();
        this.start = start;
        this.length = end - start;
    }
    next() {
        this.iterable[this.index] = this.start;
        this.start += 1;
        return super.next();
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
for (let number of new Range(1, 5)) {
    console.log(number);
}

// Logs: 1
// Logs: 2
// Logs: 3
// Logs: 4
        </code></pre>

        <aside class="notes">
            <p>Here's an Iterator that doesn't populate its data until it needs to.</p>
        </aside>

    </section>

    <section>

        <p>If this interests you, JavaScript also has generators to simplify iterators.</p>

        <pre><code class="js" data-trim>
let iterable = {
    *[Symbol.iterator]() {
        yield "one";
        yield "two";
        yield "three";
    }
}

for (let value of iterable) {
    console.log(value);
}

// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <aside class="notes">
            <p>There are precious few times you can use this, but when you get the chance it's cool as hell.</p>
        </aside>

    </section>

</section><!-- Iterator -->

<!--
*   Singleton Pattern.
*   Mediator Pattern.
*   Factory Pattern.
*   Adapter Pattern.
*   Observer Pattern.
*   Decorator Pattern.
*   Composite Pattern.
*   Iterator Pattern.
-->

<section id="questions">
    <h1>Any questions?</h1>
</section>

    </div>
</div>



<!-- <script src="../reveal/lib/js/head.min.js"></script> -->
<script src="../reveal/js/reveal.js"></script>
<script>
Reveal.configure({
    pdfSeparateFragments: false,
    pdfMaxPagesPerSlide: 1
});
Reveal.initialize({
    dependencies: [
        // Speaker notes.
        {
            src: "../reveal/plugin/notes/notes.js",
            async: true
        },
        // Syntax highlighting.
        {
            src: "../reveal/plugin/highlight/highlight.js",
            async: true,
            callback: function () {
                hljs.initHighlightingOnLoad();
            }
        },
        // PDF printing.
        {
            src: "../reveal/plugin/print-pdf/print-pdf.js",
            async: true
        }
    ]
});
</script>
<script src="./colour-fragments.js"></script>
<script src="./Checkboxes.js"></script>

</body>
</html>
