<!doctype html>
<html lang="en-GB">
<head>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1, width=device-width">
<title>Object Calisthenics</title>

<link rel="stylesheet" href="../reveal/css/reveal.css">
<link rel="stylesheet" href="../reveal/css/theme/black.css">
<link rel="stylesheet" href="../reveal/lib/css/zenburn.css">
<link rel="stylesheet" href="../custom.css">
<link rel="stylesheet" href="../reveal/css/print/pdf.css" media="print">

<style>
.reveal figure > img {
    max-height: 50vh;
}

.reveal pre code {
    max-height: 411px; /* 15 lines */
}
</style>

</head>
<body>

<div class="reveal">
    <div class="slides">

<section>
    <h1>Object Calisthenics</h1>
    <p>Exercises to super-charge your OOP skills.</p>
</section>

<!--
What is the exercise?
How to do it?
-or-
Why do it?
How to do it?
-->

<section>

    <section>
        <h2>1. Only One Indent Level</h2>
    </section>

    <section>

        <pre><code class="js" data-trim>
class Thing {
    constructor() {
        while (something) {
            // Indent level 1 :)
        }
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
class Thing {
    constructor() {
        while (something) {
            // Indent level 1 :)
            if (query) {
                // Ident level 2 :(
            }
        }
    }
}
        </code></pre>

    </section>

    <section>

        <p>This applies to anonymous function as well.</p>


        <pre><code class="js" data-trim>
class Table {
    drawTable(table) {
        let html = "&lt;table&gt;";
        table.forEach(
            (row) =&gt; /* Indent level 1 :) */
        )
        return html + "&lt;/table&gt;";
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
class Table {
    drawTable(table) {
        let html = "&lt;table&gt;";
        table.forEach(
            (row) =&gt; row.forEach(
                (cell) =&gt; /* Indent level 2 :( */
            )
        )
        return html + "&lt;/table&gt;";
    }
}
        </code></pre>

    </section>

    <section>

        <p>Keeping to 1 indent level makes your code easier to follow because your functions only do one thing.</p>

        <pre class="tall"><code class="js" data-trim>
class Table {
    drawTable(table) {
        let html = "&lt;table&gt;";
        table.forEach((row) =&gt; html += this.drawRow(row));
        return html + "&lt;/table&gt;";
    }
    drawRow(row) {
        let html = "&lt;tr&gt;";
        row.forEach((cell) =&gt; html += this.drawCell(cell));
        return html + "&lt;/tr&gt;";
    }
    drawCell(cell) {
        return "&lt;td&gt;" + cell + "&lt;/td&gt;";
    }
}
        </code></pre>

        <p class="fragment">As a bonus, the method names are very easy to understand as a result.</p>

    </section>

    <section>

        <p>It also makes your code much easier to extend.</p>

        <pre class="tall"><code class="js" data-trim>
class HeadingTable extends Table {
    drawRow(row) {
        let html = "&lt;tr&gt;";
        row.forEach((cell, i) =&gt; {
            html += this.decideType(cell, i);
        });
        return html + "&lt;/tr&gt;";
    }
    decideType(cell, i) {
        return (
            i === 0
            ? this.drawHeading(cell)
            : this.drawCell(cell)
        );
    }
    drawHeading(cell) {
        return "&lt;th&gt;" + cell + "&lt;/th&gt;";
    }
}
        </code></pre>

        <aside class="notes">
            <p>Also <code>if</code> statements inside an anonymous function count as an indent level.</p>
        </aside>

    </section>

    <section>

        <p>It makes code much easier to test and debug.</p>

        <pre><code class="js" data-trim>
describe("Table", () =&gt; {

    let table;

    beforeEach(() =&gt; table = new Table());

    describe("drawCell", () =&gt; {
        it("should return a string", () =&gt; {
            chai.assert.isString(table.drawCell(""));
            chai.assert.isString(table.drawCell(0));
            // ...
        });
    });

});
        </code></pre>

        <aside class="notes">
            <p>Test suit is Mocha and Chai.</p>
            <p>We don't do this here, but you should do it for personal projects.</p>
        </aside>

    </section>

    <section>

        <p>An exception is when you need to break a string across lines or pass many parameters to a function.</p>

        <pre class="tall"><code class="js" data-trim>
class Thing {
    longString() {
        if (something) {
            return (
                "This is a really long string that would " +
                "give me a horizontal scrollbar if I left " +
                "it on one line."
            );
        }
    }
    manyParams() {
        if (something) {
            doSomethingComplicated(
                firstParameter,
                secondParameter,
                // ...
            )
        }
    }
}
        </code></pre>

        <aside class="notes">
            <p>You'll need to do this if you stick to 80 characters.</p>
        </aside>

    </section>

</section>

<section>

    <section>
        <h2>2. Don't Use <code>else</code></h2>
    </section>

    <section>

        <p>Ever seen a huge nested conditional statement and you spend ages going through it trying to work out what it's doing?</p>
        <p>OOP offers a powerful tool - polymorphism. You'll never embrace that if you have <code>else</code> in your back pocket, so challenge yourself not to use it.</p>

    </section>

    <section>

        <h3>Option 1: Return early</h3>

        <pre><code class="js" data-trim>
class Thing {
    uppercase(string) {
        if (typeof string !== "string") {
            throw new TypeError("...");
        }
        if (!string) {
            return "";
        }
        return string.toUpperCase();
    }
}
        </code></pre>

    </section>

    <section>

        <p>This breaks your methods into 2 sections.</p>

        <pre><code class="js" data-trim>
class Thing {
    uppercase(string) {
        // 1. Validation checks and easy-outs.
        if (typeof string !== "string") {
            throw new TypeError("...");
        }
        if (!string) {
            return "";
        }
        // 2. Actual processing.
        return string.toUpperCase();
    }
}
        </code></pre>

        <aside class="notes">
            <p>A cached value existing is a good example of an easy-out.</p>
        </aside>

    </section>

    <section>

        <h3>Option 2: Null Object Pattern</h3>

        <p>A Null Object has the same interface as the normal object but it does nothing.</p>

        <pre><code class="js" data-trim>
class Cat {
    sound() { return "meow"; }
}
class NullAnimal {
    sound() {}
}
        </code></pre>
        <pre><code class="js" data-trim>
function getAnimal(type) {
    if (type === "cat") { return new Cat(); }
    return new NullAnimal();
}
["cat", "snake"].map((a) => getAnimal(a).sound());
// -&gt; ["meow", undefined]
        </code></pre>

        <aside class="notes">
            <p>This is a full embrace of <strong>polymorphism</strong>.</p>
        </aside>

    </section>

    <section>

        <h3>Option 3: Ternary Operator</h3>

        <p>Ternary operators are allowed even though they're a short-cut for <code>if...else</code>. But write them like this:</p>

        <pre><code class="js" data-trim>
let result = (
    condition
    ? resultIfTrue
    : resultIfFalse
);
        </code></pre>

        <p class="fragment">As well as being easier to read, this has a single level of indentation. A nested ternary would have a second level of identation and go against rule 1.</p>

    </section>

</section>

<section>

    <section>
        <h2>3. Wrap All Primitives and Strings</h2>
    </section>

<!--

class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }
}

class Email {
    constructor(email) {
        if (!(/^.../i).test(email)) {
            throw new ValidationError("...");
        }
        this.email = email;
    }
}
// ^ This stops people typing crazy things like
// new User("JLo", "01234000000") or new User("JLo", "Lorem ipsum dolor ...");

-->

    <section>

        <p>With a wrapped primitive we can easily see what the primitive represents.</p>

        <pre><code class="js" data-trim>
class NameTag {
    display(name) {
        alert(name.toSring());
    }
}
        </code></pre>

        <p>These would work, but does it make sense for them to be used?</p>

        <pre><code class="js" data-trim>
let tag1 = new NameTag("JLo");
let tag2 = new NameTag(123);
let tag3 = new NameTag(new Date());
        </code></pre>

    </section>

    <section>

        <p>Compare that to something like this.</p>

        <pre><code class="js" data-trim>
class Name {
    constructor(name) { this.name = name; }
    setAlias(alias) { this.alias = alias; }
    toString() { return this.alias || this.name; }
}

let tag1 = new NameTag(new Name("JLo"));
        </code></pre>

        <div class="fragment">

            <p>We can validate the data on the way in.</p>

            <pre><code class="js" data-trim>
class NameTag {
    display(name) {
        if (!(name instanceof Name)) {
            throw new TypeError("...");
        }
        alert(name.toSring());
    }
}
            </code></pre>

        </div>

    </section>

    <section>

        <p>This works really well with languages that have type-hinting.</p>

        <pre><code class="php" data-trim>
&lt;?php
class NameTag
{
    public function display(NameInterface $name)
    {
        echo $name->toString();
    }
}
        </code></pre>

    </section>

    <section>

        <p>We can also check the primative in the <code>Name</code> class. For example, if you use emoji, JavaScript can go strange.</p>
        <pre><code class="js">"ðŸ’©".length === 2</code></pre>

        <div class="fragment">
            <p>Other times, it may not make as much sense as you expect.</p>
            <pre><code class="js" data-trim>
"'".length; // -&gt; 1
"\'".length; // -&gt; 1
"\\\'".length; // -&gt; 2
            </code></pre>
        </div>

        <p class="fragment">Our <code>NameTag</code> shouldn't have to worry about that, we should handle it in <code>Name</code> keeping to the "Single Responsibility Principle".</p>

    </section>

    <section>

        <p>It will prevent you from storing data in a string. Data belongs in objects.</p>

        <pre><code class="js" data-type>
// Bad: data stored in a string.
let url1 = "https://0.0.0.0:8000/my-page.html#part";

// Get the optional port.
/:(\d+)/.test(url1) ? url1.match(/:(\d+)/)[1] : ""; // -&gt; "8000"
// Get the optional username.
// er ...
        </code></pre>

        <pre><code class="js" data-trim>
// Good: data stored in an object.
let url2 = new URL("https://0.0.0.0:8000/my-page.html#part");
// Get the optional port.
url2.port; // -&gt; "8000"
// Get the optional username.
url2.username; // -&gt; ""
        </code></pre>

        <aside class="notes">
            <p><code>URL</code> is a native class that can be polyfilled for IE11.</p>
        </aside>

    </section>

    <section>

        <p>The primative types are:</p>
        <ul>
            <li>String</li>
            <li>Number</li>
            <li>Boolean</li>
            <li>Null</li>
            <li>Undefined</li>
        </ul>

<!--
Only wrap primatives with behaviour.
UUID / BIC, IBAN / email, URL / IP address
-->

        <p class="fragment">You will have to use the primatives at some point, but don't pass them around - wrap them.</p>

    </section>


</section>

<section>

    <section>
        <h2>4. First Class Collections</h2>
    </section>

    <!-- Array, Object? -->

    <section>

        <p>Instead of keeping a collection of things in an array ...</p>
        <pre><code class="js" data-trim>
let elements = [];
elements.push(document.getElementById("a"));
elements.push(document.getElementById("b"));
// ...
        </code></pre>

        <div class="fragment">

            <p>... create a collection class to manage them instead.</p>
            <pre><code class="js" data-trim>
class Collection {
    constructor() {}
    add(element) {}
    size() {}
    // ...
}
            </code></pre>

        </div>

    </section>

    <section>

        <p>You can keep all your functionality in the new collection.</p>

        <div class="fragment">
            <p>For example, maybe you want to ensure that the collection only contains unique elements.</p>
            <pre><code class="js" data-trim>
class Collection {
    // ...
    includes(element) {
        return this.list.includes(element);
    }
    add(element) {
        if (!this.includes(element)) {
            this.list.push(element);
        }
    }
}
            </code></pre>
        </div>

        <aside class="notes">
            <p>Maybe you only want certain types of elements to be included?</p>
        </aside>

    </section>

    <section>

        <p>Maybe you want to filter the elements sometimes.</p>

        <pre><code class="js" data-trim>
// Before:
let filtered = elements.filter((el) => el.matches(".my-class"));

// After:
let filtered = collection.filter(".my-class");
        </code></pre>

        <pre class="fragment"><code class="js" data-trim>
// Or even:
let filtered = collection.flagged();
        </code></pre>

    </section>

    <section>
        <p>This exercise is a great opportunity to use the Iterator Pattern from last week.</p>
    </section>

</section>

<section>

    <section>
        <h2>5. One Dot per Line</h2>
    </section>

<!--
item.getOne().getTwo().getThree().getFour() ...
// What if getTwo() returns null or undefined?
-->

</section>

<section>

    <section>
        <h2>6. Don't Abbreviate</h2>
    </section>

<!--
array.forEach((a) => {
    // code
    // code
    // code
    // code
    // code
    // code
    a.doSomething(); // What was a?
});
-->

</section>

<section>

    <section>
        <h2>7. Keep All Entities Small</h2>
    </section>

</section>

<section>

    <section>
        <h2>8. No More than Two Constructor Parameters</h2>
    </section>

</section>

<section>

    <section>
        <h2>9. No Getters, Setters or Properties</h2>
    </section>

    <section>

        <p>Getters and setters don't tell you anything about the object.</p>

        <pre><code class="js" data-trim>
class Score {
    constructor() {
        this.score = 0;
    }
    setScore(score) {
        this.score = score;
    }
    getScore() {
        return this.score;
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let score = new Score();
score.setScore(score.getScore() + 1);
score.getScore(); // -&gt; 1
        </code></pre>

        <aside class="notes">
            <p>You're at the mercy of <code>setScore</code> getting a number.</p>
        </aside>

    </section>

    <section>

        <p>Compare that example to this one.</p>

        <pre><code class="js" data-trim>
class Score {
    constructor() {
        this.score = 0;
    }
    increase() {
        this.score += 1;
    }
    announce() {
        return this.score;
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let score = new Score();
score.increase();
score.announce(); // -&gt; 1
        </code></pre>

        <aside class="notes">
            <p>Presumably there's a <code>decrease</code> method as well.</p>
        </aside>

    </section>

    <section>

        <p>You may remember this class from previous weeks.</p>

        <pre class="tall"><code class="js" data-trim>
class Temperature {
    static symbols = {
        celsius: "C",
        fahrenheit: "F"
    };
    constructor(value) {
        this.value = value;
    }
    celsius(format) { return this.value; }
    fahrenheit(format) { return this.value * (9 / 5) + 32; }
    format(mode = "celsius") {
        return (
            this[mode]() + "Â°" + this.constructor.symbols[mode];
        );
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let temperature = new Temperature(20);
temperature.celsius(); // -&gt; 20
temperature.fahrenheit(); // -&gt; 68
temperature.format(); // -&gt; "20Â°C"
        </code></pre>

    </section>

</section>



<section id="questions">
    <h1>Any questions?</h1>
</section>

    </div>
</div>



<script src="../reveal/lib/js/head.min.js"></script>
<script src="../reveal/js/reveal.js"></script>
<script>
Reveal.configure({
    pdfSeparateFragments: false,
    pdfMaxPagesPerSlide: 1
});
Reveal.initialize({
    dependencies: [
        // Speaker notes.
        {
            src: "../reveal/plugin/notes/notes.js",
            async: true
        },
        // Syntax highlighting.
        {
            src: "../reveal/plugin/highlight/highlight.js",
            async: true,
            callback: function () {
                hljs.initHighlightingOnLoad();
            }
        },
        // PDF printing.
        {
            src: "../reveal/plugin/print-pdf/print-pdf.js",
            async: true
        }
    ]
});
</script>

</body>
</html>
