<!doctype html>
<html lang="en-GB">
<head>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1, width=device-width">
<title>Object Calisthenics</title>

<link rel="stylesheet" href="../reveal/css/reveal.css">
<link rel="stylesheet" href="../reveal/css/theme/black.css">
<link rel="stylesheet" href="../reveal/lib/css/zenburn.css">
<link rel="stylesheet" href="../custom.css">
<link rel="stylesheet" href="../reveal/css/print/pdf.css" media="print">

<style>
.reveal figure > img {
    max-height: 50vh;
}

.reveal pre code {
    max-height: 411px; /* 15 lines */
}
</style>

</head>
<body>

<div class="reveal">
    <div class="slides">

<section>
    <h1>Object Calisthenics</h1>
    <p>Exercises to super-charge your OOP skills.</p>
</section>

<!--
What is the exercise?
How to do it?
-or-
Why do it?
How to do it?
-->

<section>

    <section>
        <h2>1. Only One Indent Level</h2>
    </section>

    <section>

        <figure>
            <img src="./hadouken.jpg" alt="">
            <figcaption>What we're trying to avoid</figcaption>
        </figure>

    </section>

    <section>

        <pre><code class="js" data-trim>
class Thing {
    constructor() {
        while (something) {
            // Indent level 1 :)
        }
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
class Thing {
    constructor() {
        while (something) {
            // Indent level 1 :)
            if (query) {
                // Ident level 2 :(
            }
        }
    }
}
        </code></pre>

    </section>

    <section>

        <p>This applies to anonymous function as well.</p>


        <pre><code class="js" data-trim>
class Table {
    drawTable(table) {
        let html = "&lt;table&gt;";
        table.forEach(
            (row) =&gt; /* Indent level 1 :) */
        )
        return html + "&lt;/table&gt;";
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
class Table {
    drawTable(table) {
        let html = "&lt;table&gt;";
        table.forEach(
            (row) =&gt; row.forEach(
                (cell) =&gt; /* Indent level 2 :( */
            )
        )
        return html + "&lt;/table&gt;";
    }
}
        </code></pre>

    </section>

    <section>

        <p>Keeping to 1 indent level makes your code easier to follow because your functions only do one thing.</p>

        <pre class="tall"><code class="js" data-trim>
class Table {
    drawTable(table) {
        let html = "&lt;table&gt;";
        table.forEach((row) =&gt; html += this.drawRow(row));
        return html + "&lt;/table&gt;";
    }
    drawRow(row) {
        let html = "&lt;tr&gt;";
        row.forEach((cell) =&gt; html += this.drawCell(cell));
        return html + "&lt;/tr&gt;";
    }
    drawCell(cell) {
        return "&lt;td&gt;" + cell + "&lt;/td&gt;";
    }
}
        </code></pre>

        <p class="fragment">As a bonus, the method names are very easy to understand as a result.</p>

    </section>

    <section>

        <p>It also makes your code much easier to extend.</p>

        <pre class="tall"><code class="js" data-trim>
class HeadingTable extends Table {
    drawRow(row) {
        let html = "&lt;tr&gt;";
        row.forEach((cell, i) =&gt; {
            html += this.decideType(cell, i);
        });
        return html + "&lt;/tr&gt;";
    }
    decideType(cell, i) {
        return (
            i === 0
            ? this.drawHeading(cell)
            : this.drawCell(cell)
        );
    }
    drawHeading(cell) {
        return "&lt;th&gt;" + cell + "&lt;/th&gt;";
    }
}
        </code></pre>

        <aside class="notes">
            <p>Also <code>if</code> statements inside an anonymous function count as an indent level.</p>
        </aside>

    </section>

    <section>

        <p>It makes code much easier to test and debug.</p>

        <pre><code class="js" data-trim>
describe("Table", () =&gt; {

    let table;

    beforeEach(() =&gt; table = new Table());

    describe("drawCell", () =&gt; {
        it("should return a string", () =&gt; {
            chai.assert.isString(table.drawCell(""));
            chai.assert.isString(table.drawCell(0));
            // ...
        });
    });

});
        </code></pre>

        <aside class="notes">
            <p>Test suit is Mocha and Chai.</p>
            <p>We don't do this here, but you should do it for personal projects.</p>
        </aside>

    </section>

    <section>

        <p>An exception is when you need to break a string across lines or pass many parameters to a function.</p>

        <pre class="tall"><code class="js" data-trim>
class Thing {
    longString() {
        if (something) {
            return (
                "This is a really long string that would " +
                "give me a horizontal scrollbar if I left " +
                "it on one line."
            );
        }
    }
    manyParams() {
        if (something) {
            doSomethingComplicated(
                firstParameter,
                secondParameter,
                // ...
            )
        }
    }
}
        </code></pre>

        <aside class="notes">
            <p>You'll need to do this if you stick to 80 characters.</p>
        </aside>

    </section>

</section>

<section>

    <section>
        <h2>2. Don't Use <code>else</code></h2>
    </section>

    <section>

        <p>Ever seen a huge nested conditional statement and you spend ages going through it trying to work out what it's doing?</p>
        <p>OOP offers a powerful tool - polymorphism. You'll never embrace that if you have <code>else</code> in your back pocket, so challenge yourself not to use it.</p>

    </section>

    <section>

        <h3>Option 1: Return early</h3>

        <pre><code class="js" data-trim>
class Thing {
    uppercase(string) {
        if (typeof string !== "string") {
            throw new TypeError("...");
        }
        if (!string) {
            return "";
        }
        return string.toUpperCase();
    }
}
        </code></pre>

    </section>

    <section>

        <p>This breaks your methods into 2 sections.</p>

        <pre><code class="js" data-trim>
class Thing {
    uppercase(string) {
        // 1. Validation checks and easy-outs.
        if (typeof string !== "string") {
            throw new TypeError("...");
        }
        if (!string) {
            return "";
        }
        // 2. Actual processing.
        return string.toUpperCase();
    }
}
        </code></pre>

        <aside class="notes">
            <p>A cached value existing is a good example of an easy-out.</p>
        </aside>

    </section>

    <section>

        <h3>Option 2: Null Object Pattern</h3>

        <p>A Null Object has the same interface as the normal object but it does nothing.</p>

        <pre><code class="js" data-trim>
class Cat {
    sound() { return "meow"; }
}
class NullAnimal {
    sound() {}
}
        </code></pre>
        <pre><code class="js" data-trim>
function getAnimal(type) {
    if (type === "cat") { return new Cat(); }
    return new NullAnimal();
}
["cat", "snake"].map((a) => getAnimal(a).sound());
// -&gt; ["meow", undefined]
        </code></pre>

        <aside class="notes">
            <p>This is a full embrace of <strong>polymorphism</strong>.</p>
        </aside>

    </section>

    <section>

        <h3>Option 3: Ternary Operator</h3>

        <p>Ternary operators are allowed even though they're a short-cut for <code>if...else</code>. But write them like this:</p>

        <pre><code class="js" data-trim>
let result = (
    condition
    ? resultIfTrue
    : resultIfFalse
);
        </code></pre>

        <p class="fragment">As well as being easier to read, this has a single level of indentation. A nested ternary would have a second level of identation and go against rule 1.</p>

    </section>

</section>

<section>

    <section>
        <h2>3. Wrap Primitives and Strings</h2>
    </section>

    <section>

        <p>Let's say you need to create a user with a name and e-mail address.</p>

        <pre><code class="js" data-trim>
class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }
}
        </code></pre>

        <div class="fragment">

            <p>You'll only use it properly, right?</p>

            <pre><code class="js" data-trim>
let jlo = new User("JLo", "james.long@xigen.co.uk");
let info = new User("Info", "info@xigen.co.uk");
            </code></pre>

        </div>

    </section>

    <section>

        <p>What's to stop someone doing something like this?</p>

        <pre><code class="js" data-trim>
let user1 = new User("1", "Lorem ipsum dolor sit amet");
let user2 = new User("ü§™", "Êù±‰∫¨ÈÉΩ");
        </code></pre>

        <div class="fragment">

            <p>If we wanted to use the e-mail address, we'd have to validate it every time.</p>

            <pre><code class="js" data-trim>
class User {
    // ...
    sendEmail() {
        if ((/^...$/i).test(this.email)) {
            // ...
        }
    }
}
            </code></pre>

        </div>

        <aside class="notes">
            <p>Êù±‰∫¨ÈÉΩ = Tokyo Metropolis</p>
        </aside>

    </section>

    <section>

        <p>A better way is to accept an <code>Email</code> object that's already been validated.</p>

        <pre><code class="js" data-trim>
class Email {
    constructor(email) {
        this.validate(email);
        this.email = email;
    }
    validate(email) {
        if (!(/^...$/i).test(email)) {
            throw new Error("...");
        }
    }
    toString() {
        return this.email;
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let jlo = new User("JLo", new Email("james.long@xigen.co.uk"));
        </code></pre>

    </section>

    <section>

        <p>This works really well with languages that have type-hinting.</p>

        <pre><code class="php" data-trim>
&lt;?php
class User
{
    private $name;
    private $email;
    public function __construct($name, EmailInterface $email)
    {
        $this->name = $name;
        $this->email = $email;
    }
    public function sendEmail()
    {
        $mail->send($this->email->getValue());
    }
}
        </code></pre>

    </section>

    <section>

        <p>We can also check the primative in the <code>Name</code> class. For example, if you use emoji, JavaScript can go strange.</p>
        <pre><code class="js">"üí©".length === 2</code></pre>

        <div class="fragment">
            <p>Other times, it may not make as much sense as you expect.</p>
            <pre><code class="js" data-trim>
"'".length; // -&gt; 1
"\'".length; // -&gt; 1
"\\\'".length; // -&gt; 2
            </code></pre>
        </div>

        <p class="fragment">Our <code>User</code> shouldn't have to worry about that, we should handle it in <code>Email</code> keeping to the "Single Responsibility Principle".</p>

    </section>

    <section>

        <p>The primative types are:</p>
        <ul>
            <li><code>String</code></li>
            <li><code>Number</code></li>
            <li><code>Boolean</code></li>
            <li><code>null</code></li>
            <li><code>undefined</code></li>
        </ul>

        <div class="fragment">

            <p>You don't have to wrap <em>every</em> primative, only ones with meaning or behaviour.</p>
            <p>E-mail, IP address, ISBN, URL etc.</p>

        </div>

<!--
Only wrap primatives with behaviour.
UUID / BIC, IBAN / email, URL / IP address
-->

    </section>

    <section>

        <p>Modern browsers have a <code>URL</code> class.</p>

        <pre><code class="js" data-trim>
let url = new URL(
    "http://jlo:abc123@localhost:8080/path?query=1&amp;foo=14#place"
);

url.port; // -&gt; "8080"
url.hash; // -> "#place"
url.username; // -&gt; "jlo"
url.searchParams.get("foo"); // -&gt; "14"
        </code></pre>

        <p>Older browsers can be polyfilled.</p>

    </section>

    <section>

        <p>It also handles validation.</p>

        <pre><code class="js" data-trim>
let invalid = new URL("Lorem ipsum");
// TypeError: Failed to construct 'URL': Invalid URL
        </code></pre>

        <div class="fragment">

            <p>This means I can guarantee that it's valid before I use it.</p>

            <pre><code class="js" data-trim>
// fetch() will coerce the first argument into a string.
// The same happens with `window.location.href = x`.
fetch(url)
    .then((response) => response.text())
    .then((markup) => { /* ... */ });
            </code></pre>

        </div>

    </section>

<!--

class User {
    constructor(name, email) {
        this.name = name;
        this.email = email;
    }
}

class Email {
    constructor(email) {
        if (!(/^.../i).test(email)) {
            throw new ValidationError("...");
        }
        this.email = email;
    }
}
// ^ This stops people typing crazy things like
// new User("JLo", "01234000000") or new User("JLo", "Lorem ipsum dolor ...");

-->

    <!--section>

        <p>With a wrapped primitive we can easily see what the primitive represents.</p>

        <pre><code class="js" data-trim>
class NameTag {
    display(name) {
        alert(name.toSring());
    }
}
        </code></pre>

        <p>These would work, but does it make sense for them to be used?</p>

        <pre><code class="js" data-trim>
let tag1 = new NameTag("JLo");
let tag2 = new NameTag(123);
let tag3 = new NameTag(new Date());
        </code></pre>

    </section>

    <section>

        <p>Compare that to something like this.</p>

        <pre><code class="js" data-trim>
class Name {
    constructor(name) { this.name = name; }
    setAlias(alias) { this.alias = alias; }
    toString() { return this.alias || this.name; }
}

let tag1 = new NameTag(new Name("JLo"));
        </code></pre>

        <div class="fragment">

            <p>We can validate the data on the way in.</p>

            <pre><code class="js" data-trim>
class NameTag {
    display(name) {
        if (!(name instanceof Name)) {
            throw new TypeError("...");
        }
        alert(name.toSring());
    }
}
            </code></pre>

        </div>

    </section>

    <section>

        <p>This works really well with languages that have type-hinting.</p>

        <pre><code class="php" data-trim>
&lt;?php
class NameTag
{
    public function display(NameInterface $name)
    {
        echo $name->toString();
    }
}
        </code></pre>

    </section>

    <section>

        <p>We can also check the primative in the <code>Name</code> class. For example, if you use emoji, JavaScript can go strange.</p>
        <pre><code class="js">"üí©".length === 2</code></pre>

        <div class="fragment">
            <p>Other times, it may not make as much sense as you expect.</p>
            <pre><code class="js" data-trim>
"'".length; // -&gt; 1
"\'".length; // -&gt; 1
"\\\'".length; // -&gt; 2
            </code></pre>
        </div>

        <p class="fragment">Our <code>NameTag</code> shouldn't have to worry about that, we should handle it in <code>Name</code> keeping to the "Single Responsibility Principle".</p>

    </section>

    <section>

        <p>It will prevent you from storing data in a string. Data belongs in objects.</p>

        <pre><code class="js" data-type>
// Bad: data stored in a string.
let url1 = "https://0.0.0.0:8000/my-page.html#part";

// Get the optional port.
/:(\d+)/.test(url1) ? url1.match(/:(\d+)/)[1] : ""; // -&gt; "8000"
// Get the optional username.
// er ...
        </code></pre>

        <pre><code class="js" data-trim>
// Good: data stored in an object.
let url2 = new URL("https://0.0.0.0:8000/my-page.html#part");
// Get the optional port.
url2.port; // -&gt; "8000"
// Get the optional username.
url2.username; // -&gt; ""
        </code></pre>

        <aside class="notes">
            <p><code>URL</code> is a native class that can be polyfilled for IE11.</p>
        </aside>

    </section>

    <section>

        <p>The primative types are:</p>
        <ul>
            <li>String</li>
            <li>Number</li>
            <li>Boolean</li>
            <li>Null</li>
            <li>Undefined</li>
        </ul>

<!- -
Only wrap primatives with behaviour.
UUID / BIC, IBAN / email, URL / IP address
- ->

        <p class="fragment">You will have to use the primatives at some point, but don't pass them around - wrap them.</p>

    </section-->


</section>

<section>

    <section>
        <h2>4. First Class Collections</h2>
    </section>

    <!-- Array, Object? -->

    <section>

        <p>Instead of keeping a collection of things in an array ...</p>
        <pre><code class="js" data-trim>
let elements = [];
elements.push(document.getElementById("a"));
elements.push(document.getElementById("b"));
// ...
        </code></pre>

        <div class="fragment">

            <p>... create a collection class to manage them instead.</p>
            <pre><code class="js" data-trim>
class Collection {
    constructor() {}
    add(element) {}
    size() {}
    // ...
}
            </code></pre>

        </div>

    </section>

    <section>

        <p>You can keep all your functionality in the new collection.</p>

        <div class="fragment">
            <p>For example, maybe you want to ensure that the collection only contains unique elements.</p>
            <pre><code class="js" data-trim>
class Collection {
    // ...
    includes(element) {
        return this.list.includes(element);
    }
    add(element) {
        if (!this.includes(element)) {
            this.list.push(element);
        }
    }
}
            </code></pre>
        </div>

        <aside class="notes">
            <p>Maybe you only want certain types of elements to be included?</p>
        </aside>

    </section>

    <section>

        <p>Maybe you want to filter the elements sometimes.</p>

        <pre><code class="js" data-trim>
// Before:
let filtered = elements.filter((el) => el.matches(".my-class"));

// After:
let filtered = collection.filter(".my-class");
        </code></pre>

        <pre class="fragment"><code class="js" data-trim>
// Or even:
let filtered = collection.flagged();
        </code></pre>

    </section>

    <section>
        <p>This exercise is a great opportunity to use the Iterator Pattern from last week.</p>
    </section>

</section>

<section>

    <section>
        <h2>5. One Dot per Line</h2>
    </section>

    <section>

        <p>Don't chain method calls and don't assume the results.</p>

        <pre><code class="js" data-trim>
// Bad: multiple dots.
this.getFilters()
    .first()
    .getRate()
    .addTax()
    .getRandomValue()
    // ...
    ;
        </code></pre>

        <aside class="notes">
            <p>Although there's only 1 dot per line, that statement contains multiple dots.</p>
        </aside>

    </section>

    <section>

        <p>If anything changed, the code would break.</p>
        <p>For example, what if we returned <code>null</code> from <code>.first()</code> if <code>.getFilters()</code> was empty?</p>

        <pre><code class="js" data-trim>
this.getFilters()
    .first()
    .getRate()
    // ...
    ;
// TypeError: Cannot read property 'getRate' of null
        </code></pre>

    </section>

    <section>

        <figure>
            <img src="./lod.png" alt="" style="background-color: #fff">
            <figcaption>Remember the Law of Demeter?</figcaption>
        </figure>

    </section>

    <section>

        <p>The exception is when the methods return <code>this</code> like jQuery does.</p>

        <pre><code class="js" data-trim>
$("#element")
    .attr("title", "lorem ipsum")
    .addClass("foo")
    .on("click", (e) => {})
    // ...
    ;
        </code></pre>

        <div class="fragment">
            <p>Even then, split your chain over multiple lines so there's only 1 dot per line.</p>
            <p>As well as being more readable, it helps to avoids merge conflicts.</p>
        </div>

        <aside class="notes">
            <p>Example: one dev changes the class, another adds a new event listener.</p>
        </aside>

    </section>

<!--
item.getOne().getTwo().getThree().getFour() ...
// What if getTwo() returns null or undefined?
-->

</section>

<section>

    <section>
        <h2>6. Don't Abbreviate</h2>
    </section>

    <section>

        <p>Let's say you had a huge <code>forEach</code> function.</p>

        <pre><code class="js" data-trim>
array.forEach((a) => {
    // code
    // code
    // code
    // code
    // code
    // code
    a.doSomething(); // What was a?
});
        </code></pre>

    </section>

    <section>

        <p>Compare this class definition ...</p>

        <pre><code class="js" data-trim>
class Cst {
    isM() {}
    isF() {}
    isRdOn() {}
    addG(g) {}
    addAddr(addr) {}
    getAttr(attr) {}
    getStr() {}
    setPwdHash(p) {}
}
        </code></pre>

    </section>

    <section>

        <p>... to this one.</p>

        <pre><code class="js" data-trim>
class Customer {
    isMale() {}
    isFemale() {}
    isReadOnly() {}
    addGroup(group) {}
    addAddress(address) {}
    getAttribute(attribute) {}
    getStore() {}
    setPasswordHash(password) {}
}
        </code></pre>

        <p class="fragment">Isn't that just easier to read?</p>

    </section>

    <section>

        <p>Abbreviating makes you feel clever, but it masks other problems.</p>

        <div class="fragment">
            <p>Are you abbreviating because typing the same word multiple times is time-consuming?</p>
            <p>Perhaps the method is being used too often and you're missing an opportunity to remove duplication.</p>
        </div>

    </section>

    <section>

        <p>Is your method name getting too long?</p>
        <p>It probably does too much. Your method name can probably be written in 2 words.</p>
        <p class="fragment">You can also work things out from context - the <code>shipOrder</code> method on the <code>Order</code> class can just be called "ship". <code>order.ship()</code> is easy to understand.</p>

    </section>

    <section>

        <p>There are well-known abbreviations which are fine. We usually use <code>i</code> to mean "index" when we're in a loop.</p>
        <pre><code class="js" data-trim>
// Inside a forEach()
array.forEach((item, i) => { /* ... */ });

// As a regular loop.
let i = 0;
while (i < array.length) {
    // ...
    i += 1;
}
        </code></pre>

        <p class="fragment">Leave the abbreviations to the minifier.</p>

    </section>

</section>

<section>

    <section>
        <h2>7. Keep All Entities Small</h2>
    </section>

    <section>

        <p>Long files are harder to read, so keep them small.</p>

        <ul class="fragment">
            <li>No method with over <strong>20 lines</strong>.</li>
            <li>No package with over <strong>15 files</strong>.</li>
            <li>No classes with over <strong>200 lines</strong>.</li>
        </ul>

        <p class="fragment">This is <em>extremely</em> challenging.</p>

    </section>

    <section>

        <p>If you have classes with more than 200 lines or a method with more than 20 lines, it probably does more than one thing.</p>
        <p>Try to separate them out so that each class/method only has a single responsibility.</p>

        <aside class="notes">
            <p>Whitespace and comments don't count.</p>
        </aside>

    </section>

    <section>

        <p>This will teach you segregation and modularity.</p>
        <p>It will encourage you to keep your classes and methods concentrated on a single responsibility.</p>
        <p class="fragment">There is some debate about the actual numbers. I've also heard maximum of <strong>10 lines</strong> per method, maximum of <strong>10 methods</strong> per class.</p>
        <p class="fragment">The original article said <q>no class over 50 lines and no package over 10 files</q>.</p>

        <aside class="notes">
            <p>Important question to ask yourself: "did I need to add that line/file?"</p>
        </aside>

    </section>

</section>

<section>

    <section>
        <h2>8. No More than Two Constructor Parameters</h2>
    </section>

    <section>

        <p>This is pretty easy to understand.</p>

        <pre><code class="js" data-trim>
class TwoParameters {
    constructor(lorem, ipsum) {
        // ...
    }
}

class ThreeParameters {
    constructor(lorem, ipsum, dolor) {
        // ...
    }
}
        </code></pre>

    </section>

    <section>

        <p>If you class needs more than 2 paramters to set it up, it's probably worried about too many things.</p>
        <p class="fragment">Do you need all those parameters at the start or can you add others later on using other methods?</p>
        <p class="fragment">Have you considered using a mediator class to manage all the different dependencies?</p>

    </section>

</section>

<section>

    <section>
        <h2>9. No Getters, Setters or Properties</h2>
    </section>

    <section>

        <p>Getters and setters don't tell you anything about the object.</p>

        <pre><code class="js" data-trim>
class Score {
    constructor() {
        this.score = 0;
    }
    setScore(score) {
        this.score = score;
    }
    getScore() {
        return this.score;
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let score = new Score();
score.setScore(score.getScore() + 1);
score.getScore(); // -&gt; 1
        </code></pre>

        <aside class="notes">
            <p>You're at the mercy of <code>setScore</code> getting a number.</p>
        </aside>

    </section>

    <section>

        <p>Compare that example to this one.</p>

        <pre><code class="js" data-trim>
class Score {
    constructor() {
        this.score = 0;
    }
    increase() {
        this.score += 1;
    }
    announce() {
        return this.score;
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let score = new Score();
score.increase();
score.announce(); // -&gt; 1
        </code></pre>

        <aside class="notes">
            <p>Presumably there's a <code>decrease</code> method as well.</p>
        </aside>

    </section>

    <section>

        <p>You may remember this class from previous weeks.</p>

        <pre class="tall"><code class="js" data-trim>
class Temperature {
    static symbols = {
        celsius: "C",
        fahrenheit: "F"
    };
    constructor(value) {
        this.value = value;
    }
    celsius(format) { return this.value; }
    fahrenheit(format) { return this.value * (9 / 5) + 32; }
    format(mode = "celsius") {
        return (
            this[mode]() + "¬∞" + this.constructor.symbols[mode];
        );
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
let temperature = new Temperature(20);
temperature.celsius(); // -&gt; 20
temperature.fahrenheit(); // -&gt; 68
temperature.format(); // -&gt; "20¬∞C"
        </code></pre>

    </section>

    <section>
        <p>This is just <strong>encapsulation</strong>.</p>
        <p>We should be able to change how data is stored or how processes operate without re-writing a lot of the code, the object should handle that for us.</p>
    </section>

</section>



<section id="questions">
    <h1>Any questions?</h1>
</section>

    </div>
</div>



<script src="../reveal/lib/js/head.min.js"></script>
<script src="../reveal/js/reveal.js"></script>
<script>
Reveal.configure({
    pdfSeparateFragments: false,
    pdfMaxPagesPerSlide: 1
});
Reveal.initialize({
    dependencies: [
        // Speaker notes.
        {
            src: "../reveal/plugin/notes/notes.js",
            async: true
        },
        // Syntax highlighting.
        {
            src: "../reveal/plugin/highlight/highlight.js",
            async: true,
            callback: function () {
                hljs.initHighlightingOnLoad();
            }
        },
        // PDF printing.
        {
            src: "../reveal/plugin/print-pdf/print-pdf.js",
            async: true
        }
    ]
});
</script>

</body>
</html>
