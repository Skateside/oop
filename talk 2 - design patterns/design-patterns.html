<!doctype html>
<html lang="en-GB">
<head>

<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1, width=device-width">
<title>Design Patterns</title>

<link rel="stylesheet" href="../reveal/css/reveal.css">
<link rel="stylesheet" href="../reveal/css/theme/black.css">
<link rel="stylesheet" href="../reveal/lib/css/zenburn.css">
<link rel="stylesheet" href="../custom.css">
<link rel="stylesheet" href="../reveal/css/print/pdf.css" media="print">

</head>
<body>

<div class="reveal">
    <div class="slides">

<section>
    <h1>Design Patterns</h1>
    <p>Common OOP patterns.</p>
</section>

<!-- What is a design pattern? -->

<section>

    <section>

<style>
.display {
    transition: all .2s ease;
}

.display-blue {
    color: #1b91ff;
}

.display-green {
    color: #17ff2e;
}

.boxes {
    display: flex;
    flex-flow: row nowrap;
    justify-content: space-around;
}

.box {
    font-size: 0.5em;
    text-align: left;
}

.box .box__list {
    list-style-type: none;
    margin: 0;
    padding: 0;
}

.books {
    display: flex;
    flex-flow: row nowrap;
    justify-content: space-around;
}

.book {
    font-size: 0.5em;
}

.reveal .book > img {
    max-height: 15vh;
}
</style>

        <div class="boxes">
            <div class="box">
                <h2 class="box__title">Creational</h2>
                <ul class="box__list">
                    <li>Abstract factory</li>
                    <li>Builder</li>
                    <li class="js--fragment--one js--fragment--two // display">Factory</li>
                    <li>Prototype</li>
                    <li class="js--fragment--one js--fragment--two // display">Singleton</li>
                </ul>
            </div>
            <div class="box">
                <h2 class="box__title">Structural</h2>
                <ul class="box__list">
                    <li class="js--fragment--one js--fragment--two // display">Adapter</li>
                    <li class="js--fragment--one // display">Bridge</li>
                    <li class="js--fragment--one js--fragment--two // display">Composite</li>
                    <li class="js--fragment--one js--fragment--two // display">Decorator</li>
                    <li class="js--fragment--one // display">Facade</li>
                    <li class="js--fragment--one // display">Flyweight</li>
                    <li class="js--fragment--one // display">Proxy</li>
                </ul>
            </div>
            <div class="box">
                <h2 class="box__title">Behavioural</h2>
                <ul class="box__list">
                    <li class="js--fragment--one // display">Chain of responsibility</li>
                    <li class="js--fragment--one // display">Command</li>
                    <li>Interpreter</li>
                    <li class="js--fragment--two // display">Iterator</li>
                    <li>Mediator</li>
                    <li>Memento</li>
                    <li class="js--fragment--one js--fragment--two // display">Observer</li>
                    <li>State</li>
                    <li>Strategy</li>
                    <li>Template method</li>
                    <li>Visitor</li>
                </ul>
            </div>
        </div>

        <div class="books">

            <figure class="book">
                <img src="./design-patterns-book.jpg">
                <figcaption>Design Patterns (1994)</figcaption>
            </figure>

            <figure class="book // fragment" id="pro-js-dp">
                <img src="./pro-js-design-patterns-book.jpg">
                <figcaption>Pro JavaScript Design Patterns (2008)</figcaption>
            </figure>

        </div>

        <div class="fragment" id="this-talk"></div>

    </section>

</section>

<section>

    <section>
        <h2>Iterator Pattern</h2>
    </section>

    <section>

        <p>The iterator pattern exposes elements of an object sequentially without exposing the underlying data structure.</p>

        <aside class="notes">
            <p>It's, like, <em>way</em> cooler than it sounds.</p>
        </aside>

    </section>

    <section>

        <p>The key part of an Iterator is the <code>next</code> method which returns an object.</p>

        <pre><code class="js" data-trim>
class Iterator {
    constructor(iterable = []) {
        this.index = 0;
        this.length = iterable.length;
        this.iterable = iterable;
    }
    next() {
        let value = this.iterable[this.index];
        this.index += 1;
        return Object.freeze({
            value,
            done: this.index > this.length
        });
    }
}
        </code></pre>

        <aside class="notes">
            <p>A "Crockford Classless" version of this wouldn't expose the properties at all.</p>
        </aside>

    </section>

    <section>

        <p>The <code>next</code> method will return the value and whether or not the loop is complete.</p>
        <p>The final entry shouldn't have a value - any value will be ignored.</p>

        <pre><code class="js" data-trim>
let iterator = new Iterator(["one", "two", "three"]);
iterator.next(); // -&gt; { value: "one", done: false }
iterator.next(); // -&gt; { value: "two", done: false }
iterator.next(); // -&gt; { value: "three", done: false }
iterator.next(); // -&gt; { value: undefined, done: true }
        </code></pre>

        <aside class="notes">
            <p>I know what you're thinking: why not just loop over an array?</p>
        </aside>

    </section>

    <section>

        <p>Have you heard of a <code>for...of</code> loop?</p>

        <pre><code class="js" data-trim>
for (let item of ["one", "two", "three"]) {
    console.log(item);
}
// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <div class="fragment">

            <p>JavaScript allows you to define custom functionality for that using the <code>Symbol.iterator</code> method.</p>
            <p>That method needs to return an iterator.</p>

        </div>

        <pre class="fragment"><code class="js" data-trim>
class Iterator {
    // ...
    [Symbol.iterator]() {
        return this;
    }
}
        </code></pre>

    </section>

    <section>

        <pre><code class="js" data-trim>
let iterator = new Iterator(["one", "two", "three"]);

for (let item of iterator) {
    console.log(item);
}

// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <div class="fragment">

            <p>It also activates JavaScript's spread operator.</p>

            <pre><code class="js" data-trim>
[...iterator]; // -&gt; ["one", "two", "three"]
            </code></pre>

        </div>

    </section>

    <section>

        <p>An Iterator allows the items to be converted while being looped over without revealing that information.</p>

        <pre><code class="js" data-trim>
class Name {
    constructor(name) { this.name = name; }
    setAlias(alias) { this.alias = alias; }
    getName() { return this.alias || this.name; }
}

class Employees extends Iterator {
    next() {
        let value = this.iterable[this.index].getName();
        // ...
    }
}
        </code></pre>
    </section>
    <section>

        <p>As far as our loop knows, we just have an array of strings.</p>

        <pre><code class="js" data-trim>
let mark = new Name("Mark");
let james = new Name("James");
let jlo = new Name("James");
jlo.setAlias("JLo");

let employees = new Employees([mark, james, jlo])

for (let employee of employees) {
    console.log(employee);
}

// Logs: "Mark"
// Logs: "James"
// Logs: "JLo"
        </code></pre>

        <aside class="notes">
            <p>If we need to do something like HTML-entities -&gt; UTF-8 or enforce capitalisation, it won't polute the array.</p>
        </aside>

    </section>

    <section>

        <p>An Iterator can not only abstract the data that it's serving, it can abstract the underlying data structure as well.</p>
        <p>We've been using an array but it could also be an object ... <span class="fragment">or nothing at all.</span></p>

    </section>

    <section>

        <pre><code class="js" data-trim>
class Range extends Iterator {
    constructor(start, end) {
        super();
        this.start = start;
        this.length = end - start;
    }
    next() {
        this.iterable[this.index] = this.start;
        this.start += 1;
        return super.next();
    }
}
        </code></pre>

        <pre><code class="js" data-trim>
for (let number of new Range(1, 5)) {
    console.log(number);
}

// Logs: 1
// Logs: 2
// Logs: 3
// Logs: 4
        </code></pre>

        <aside class="notes">
            <p>Here's an Iterator that doesn't populate its data until it needs to.</p>
        </aside>

    </section>

    <section>

        <p>If this interests you, JavaScript also has generators to simpliy iterators.</p>

        <pre><code class="js" data-trim>
let iterable = {
    *[Symbol.iterator]() {
        yield "one";
        yield "two";
        yield "three";
    }
}

for (let value of iterable) {
    console.log(value);
}

// Logs: "one"
// Logs: "two"
// Logs: "three"
        </code></pre>

        <aside class="notes">
            <p>There are precious few times you can use this, but when you get the chance it's cool as hell.</p>
        </aside>

    </section>

</section>

<section>

    <section>
        <h2>Composite Pattern</h2>
    </section>

    <section>

        <p>The Composite pattern takes zero-or-more similar objects and treats them as one object.</p>

        <figure class="fragment">
            <img src="./branch-leaves.png" alt="" class="mini-image">
            <figcaption>It does this by having "branches" that contain objects and "leaves" which are the objects.</figcaption>
        </figure>

    </section>

    <section>

        <p>In abstract terms, it looks like this.</p>

        <pre><code class="js" data-trim>
class Branch {
    constructor() { this.nodes = []; }
    addNode(node) { this.nodes.push(node); }
    doSomething() { this.nodes.forEach((o) => o.doSomething()); }
}

class Leaf {
    doSomething() {/* ... */}
}
        </code></pre>

        <p>The important thing is that either a <code>Branch</code> or a <code>Leaf</code> can be passed to <code>addNode</code>.</p>

    </section>

    <section>

        <form class="o-pack">
            <input type="number">
            <input type="number">
            <input type="number">
            <button type="submit">Generate</button>
        </form>

    </section>

</section>

<!--
    Decorator Pattern.
    Composite Pattern.
    Adapter Pattern.
    Observer Pattern. (but in OOP ...)
    Factory Pattern. (it's mentioned a load of times ...)
*   Iterator Pattern. (https://en.wikipedia.org/wiki/Iterator_pattern)
    Singleton Pattern.
-->



<section id="questions">
    <h1>Any questions?</h1>
</section>

    </div>
</div>



<!-- <script src="../reveal/lib/js/head.min.js"></script> -->
<script src="../reveal/js/reveal.js"></script>
<script>
Reveal.configure({
    pdfSeparateFragments: false,
    pdfMaxPagesPerSlide: 1
});
Reveal.initialize({
    dependencies: [
        // Speaker notes.
        {
            src: "../reveal/plugin/notes/notes.js",
            async: true
        },
        // Syntax highlighting.
        {
            src: "../reveal/plugin/highlight/highlight.js",
            async: true,
            callback: function () {
                hljs.initHighlightingOnLoad();
            }
        },
        // PDF printing.
        {
            src: "../reveal/plugin/print-pdf/print-pdf.js",
            async: true
        }
    ]
});

/*
var fragSelectors = Array.prototype.reduce.call(
    document.querySelectorAll("[data-fragment]"),
    function (unique, el) {

        if (!unique.includes(el.dataset.fragment)) {
            unique.push(el.dataset.fragment);
        }

        return unique;

    },
    []
);
Reveal.addEventListener("fragmentshown", function (e) {

    var fragment = e.fragment;

    fragSelectors.forEach(function (fragSelector) {

        if (fragment.matches(fragSelector)) {

            document.querySelectorAll("[data-fragment=\"" + fragSelector + "\"]").forEach(function (frag) {
                frag.classList.add("visible");
            });

        }

    });

});
*/

var colourFrags = [
    {
        check: "#pro-js-dp",
        find: ".js--fragment--one",
        className: "display-blue"
    },
    {
        check: "#this-talk",
        find: ".js--fragment--two",
        className: "display-green"
    }
];

Reveal.addEventListener("fragmentshown", ({ fragment }) => {

    colourFrags.forEach(({ check, find, className }) => {

        if (fragment.matches(check)) {

            document.querySelectorAll(find).forEach(function (el) {
                el.classList.add(className);
            });

        }

    });

});

Reveal.addEventListener("fragmenthidden", ({ fragment }) => {

    colourFrags.forEach(({ check, find, className }) => {

        if (fragment.matches(check)) {

            document.querySelectorAll(find).forEach(function (el) {
                el.classList.remove(className);
            });

        }

    });

});
</script>

</body>
</html>
